---
phase: 03-payroll-compliance
plan: 06
type: execute
wave: 3
depends_on: ["03-04"]
files_modified:
  - src/lib/statutory/file-generators/ecr.ts
  - src/lib/statutory/file-generators/esi-challan.ts
  - src/app/api/payroll/[runId]/statutory/ecr/route.ts
  - src/app/api/payroll/[runId]/statutory/esi/route.ts
  - prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "System generates ECR file in EPFO format with #~# separators"
    - "ECR file contains correct UAN, wages, and PF contributions for all employees"
    - "System generates ESI challan file with employee and employer contributions"
    - "Generated files can be downloaded and are ready for portal upload"
  artifacts:
    - path: "src/lib/statutory/file-generators/ecr.ts"
      provides: "ECR text file generator"
      exports: ["generateECRFile", "generateECRForPayrollRun"]
    - path: "src/lib/statutory/file-generators/esi-challan.ts"
      provides: "ESI challan generator"
      exports: ["generateESIChallan"]
    - path: "src/app/api/payroll/[runId]/statutory/ecr/route.ts"
      provides: "ECR download API"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/payroll/[runId]/statutory/ecr/route.ts"
      to: "src/lib/statutory/file-generators/ecr.ts"
      via: "file generation"
      pattern: "generateECRForPayrollRun"
---

<objective>
Implement ECR and ESI challan file generators for statutory compliance

Purpose: Every month, companies must upload ECR (Electronic Challan cum Return) to EPFO portal and ESI challan to ESIC portal. These files have specific formats that portals validate. Incorrect format = rejected submission = penalties.

Output:
- ECR file generator in EPFO-compliant format
- ESI challan generator
- Download APIs for statutory files
- StatutoryFile model for tracking generated files
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payroll-compliance/03-RESEARCH.md
@.planning/phases/03-payroll-compliance/03-04-SUMMARY.md
@src/lib/payroll/types.ts
@src/lib/payroll/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StatutoryFile model and ECR generator</name>
  <files>
    prisma/schema.prisma
    src/lib/statutory/file-generators/ecr.ts
  </files>
  <action>
1. Add StatutoryFile model to schema.prisma:
```prisma
model StatutoryFile {
  id String @id @default(cuid())

  payroll_run_id String
  payroll_run    PayrollRun @relation(fields: [payroll_run_id], references: [id])

  type     StatutoryFileType
  filename String
  filepath String // Local storage path

  // File metadata
  file_size     Int
  record_count  Int // Number of employees in file
  total_amount_paise Int // Total amount (for verification)

  // Generation tracking
  generated_at DateTime @default(now())
  generated_by String?

  // Upload tracking (when uploaded to portal)
  uploaded_at       DateTime?
  upload_reference  String?   // Portal acknowledgment number
  upload_status     String?   // SUCCESS, PENDING, FAILED

  @@index([payroll_run_id, type])
  @@map("statutory_files")
}

enum StatutoryFileType {
  ECR            // PF Electronic Challan Return
  ESI_CHALLAN    // ESI monthly challan
  FORM_24Q       // Quarterly TDS return
  FORM_16        // Annual TDS certificate
  PT_RETURN      // Professional Tax return
}
```

Add relation to PayrollRun:
```prisma
  statutory_files StatutoryFile[]
```

2. Create src/lib/statutory/file-generators/ecr.ts:
```typescript
import { prisma } from '@/lib/db';
import { paiseToRupees } from '@/lib/payroll/types';

export interface ECREmployee {
  uan: string;
  memberName: string;
  grossWagesPaise: number;
  epfWagesPaise: number;
  epsWagesPaise: number;
  edliWagesPaise: number;
  employeeEPFPaise: number;
  employerEPFPaise: number;
  employerEPSPaise: number;
  employerEDLIPaise: number;
  ncpDays: number; // Non-contribution period (LOP days)
  refundOfAdvances: number;
}

export interface ECRHeader {
  establishmentId: string;
  establishmentName: string;
  wageMonth: string; // MM/YYYY format
  memberCount: number;
  grossWagesTotal: number;
  epfWagesTotal: number;
  employeeEPFTotal: number;
  employerEPFTotal: number;
  employerEPSTotal: number;
  employerEDLITotal: number;
}

const ECR_SEPARATOR = '#~#';

/**
 * Generate ECR file content in EPFO format
 *
 * ECR Format (11 fields per line):
 * UAN#~#Member Name#~#Gross Wages#~#EPF Wages#~#EPS Wages#~#EDLI Wages#~#
 * Employee EPF#~#Employer EPF#~#Employer EPS#~#Employer EDLI#~#NCP Days#~#Refund
 */
export function generateECRFile(
  header: ECRHeader,
  employees: ECREmployee[]
): string {
  const lines: string[] = [];

  // Header line (summary)
  const headerLine = [
    header.establishmentId,
    header.establishmentName,
    header.wageMonth,
    header.memberCount.toString(),
    formatAmount(header.grossWagesTotal),
    formatAmount(header.epfWagesTotal),
    formatAmount(header.employeeEPFTotal),
    formatAmount(header.employerEPFTotal),
    formatAmount(header.employerEPSTotal),
    formatAmount(header.employerEDLITotal),
    '0', // NCP days at summary level
    '0', // Refund at summary level
  ].join(ECR_SEPARATOR);

  lines.push(headerLine);

  // Employee lines
  for (const emp of employees) {
    // Skip employees without UAN
    if (!emp.uan) continue;

    const employeeLine = [
      emp.uan,
      emp.memberName.toUpperCase(), // EPFO expects uppercase
      formatAmount(emp.grossWagesPaise),
      formatAmount(emp.epfWagesPaise),
      formatAmount(emp.epsWagesPaise),
      formatAmount(emp.edliWagesPaise),
      formatAmount(emp.employeeEPFPaise),
      formatAmount(emp.employerEPFPaise),
      formatAmount(emp.employerEPSPaise),
      formatAmount(emp.employerEDLIPaise),
      emp.ncpDays.toString(),
      emp.refundOfAdvances.toString(),
    ].join(ECR_SEPARATOR);

    lines.push(employeeLine);
  }

  return lines.join('\n');
}

/**
 * Format amount from paise to rupees with 2 decimal places
 */
function formatAmount(paise: number): string {
  return paiseToRupees(paise).toFixed(2);
}

/**
 * Generate ECR file for a completed payroll run
 */
export async function generateECRForPayrollRun(
  payrollRunId: string,
  establishmentId: string,
  establishmentName: string
): Promise<{
  content: string;
  filename: string;
  recordCount: number;
  totalAmountPaise: number;
}> {
  // Get payroll run with records
  const payrollRun = await prisma.payrollRun.findUnique({
    where: { id: payrollRunId },
    include: {
      records: {
        where: {
          status: { in: ['CALCULATED', 'VERIFIED', 'PAID'] },
          pf_employee_paise: { gt: 0 }, // Only include PF-contributing employees
        },
        include: {
          employee: true,
        },
      },
    },
  });

  if (!payrollRun) {
    throw new Error('Payroll run not found');
  }

  // Build employee data
  const employees: ECREmployee[] = payrollRun.records
    .filter(r => r.employee.uan) // Must have UAN
    .map(record => ({
      uan: record.employee.uan!,
      memberName: `${record.employee.first_name} ${record.employee.last_name}`,
      grossWagesPaise: record.gross_salary_paise,
      epfWagesPaise: record.pf_base_paise,
      epsWagesPaise: record.pf_base_paise,
      edliWagesPaise: record.pf_base_paise,
      employeeEPFPaise: record.pf_employee_paise,
      employerEPFPaise: record.pf_employer_epf_paise,
      employerEPSPaise: record.pf_employer_eps_paise,
      employerEDLIPaise: record.pf_employer_edli_paise,
      ncpDays: record.lop_days,
      refundOfAdvances: 0,
    }));

  // Calculate totals
  const totals = employees.reduce(
    (acc, emp) => ({
      grossWages: acc.grossWages + emp.grossWagesPaise,
      epfWages: acc.epfWages + emp.epfWagesPaise,
      employeeEPF: acc.employeeEPF + emp.employeeEPFPaise,
      employerEPF: acc.employerEPF + emp.employerEPFPaise,
      employerEPS: acc.employerEPS + emp.employerEPSPaise,
      employerEDLI: acc.employerEDLI + emp.employerEDLIPaise,
    }),
    {
      grossWages: 0,
      epfWages: 0,
      employeeEPF: 0,
      employerEPF: 0,
      employerEPS: 0,
      employerEDLI: 0,
    }
  );

  const header: ECRHeader = {
    establishmentId,
    establishmentName,
    wageMonth: `${String(payrollRun.month).padStart(2, '0')}/${payrollRun.year}`,
    memberCount: employees.length,
    grossWagesTotal: totals.grossWages,
    epfWagesTotal: totals.epfWages,
    employeeEPFTotal: totals.employeeEPF,
    employerEPFTotal: totals.employerEPF,
    employerEPSTotal: totals.employerEPS,
    employerEDLITotal: totals.employerEDLI,
  };

  const content = generateECRFile(header, employees);
  const filename = `ECR_${establishmentId}_${payrollRun.year}${String(payrollRun.month).padStart(2, '0')}.txt`;

  // Total PF amount (employee + employer)
  const totalAmountPaise =
    totals.employeeEPF +
    totals.employerEPF +
    totals.employerEPS +
    totals.employerEDLI;

  return {
    content,
    filename,
    recordCount: employees.length,
    totalAmountPaise,
  };
}

/**
 * Validate ECR employee data
 */
export function validateECREmployee(emp: Partial<ECREmployee>): string[] {
  const errors: string[] = [];

  if (!emp.uan || emp.uan.length !== 12) {
    errors.push('Invalid UAN (must be 12 digits)');
  }

  if (!emp.memberName || emp.memberName.trim().length === 0) {
    errors.push('Member name is required');
  }

  if (emp.grossWagesPaise !== undefined && emp.grossWagesPaise < 0) {
    errors.push('Gross wages cannot be negative');
  }

  if (emp.ncpDays !== undefined && (emp.ncpDays < 0 || emp.ncpDays > 31)) {
    errors.push('NCP days must be between 0 and 31');
  }

  return errors;
}
```

Run `pnpm db:push` to update database schema.
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - `pnpm db:push` succeeds
    - generateECRFile produces #~# separated text
    - Header line contains all totals
  </verify>
  <done>
    ECR file generator created with EPFO-compliant format, employee validation, and payroll run integration
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ESI challan generator</name>
  <files>
    src/lib/statutory/file-generators/esi-challan.ts
  </files>
  <action>
Create src/lib/statutory/file-generators/esi-challan.ts:

```typescript
import { prisma } from '@/lib/db';
import { paiseToRupees } from '@/lib/payroll/types';

export interface ESIChallanEmployee {
  esicNumber: string;
  employeeName: string;
  grossWagesPaise: number;
  employeeContributionPaise: number; // 0.75%
  employerContributionPaise: number; // 3.25%
  totalContributionPaise: number;
  ipDays: number; // Insurable period days (working days)
}

export interface ESIChallanSummary {
  establishmentCode: string;
  establishmentName: string;
  contributionPeriod: string; // MM/YYYY
  employeeCount: number;
  totalGrossWagesPaise: number;
  totalEmployeeContributionPaise: number;
  totalEmployerContributionPaise: number;
  totalContributionPaise: number;
  challanNumber?: string;
}

/**
 * Generate ESI challan data for a payroll run
 */
export async function generateESIChallan(
  payrollRunId: string,
  establishmentCode: string,
  establishmentName: string
): Promise<{
  summary: ESIChallanSummary;
  employees: ESIChallanEmployee[];
  csvContent: string;
  filename: string;
}> {
  // Get payroll run with ESI-applicable records
  const payrollRun = await prisma.payrollRun.findUnique({
    where: { id: payrollRunId },
    include: {
      records: {
        where: {
          status: { in: ['CALCULATED', 'VERIFIED', 'PAID'] },
          esi_applicable: true,
          esi_employee_paise: { gt: 0 },
        },
        include: {
          employee: true,
        },
      },
    },
  });

  if (!payrollRun) {
    throw new Error('Payroll run not found');
  }

  // Build employee data
  const employees: ESIChallanEmployee[] = payrollRun.records
    .filter(r => r.employee.esic_number)
    .map(record => ({
      esicNumber: record.employee.esic_number!,
      employeeName: `${record.employee.first_name} ${record.employee.last_name}`,
      grossWagesPaise: record.gross_salary_paise,
      employeeContributionPaise: record.esi_employee_paise,
      employerContributionPaise: record.esi_employer_paise,
      totalContributionPaise: record.esi_employee_paise + record.esi_employer_paise,
      ipDays: record.paid_days,
    }));

  // Calculate totals
  const totals = employees.reduce(
    (acc, emp) => ({
      grossWages: acc.grossWages + emp.grossWagesPaise,
      employeeContribution: acc.employeeContribution + emp.employeeContributionPaise,
      employerContribution: acc.employerContribution + emp.employerContributionPaise,
      total: acc.total + emp.totalContributionPaise,
    }),
    {
      grossWages: 0,
      employeeContribution: 0,
      employerContribution: 0,
      total: 0,
    }
  );

  const summary: ESIChallanSummary = {
    establishmentCode,
    establishmentName,
    contributionPeriod: `${String(payrollRun.month).padStart(2, '0')}/${payrollRun.year}`,
    employeeCount: employees.length,
    totalGrossWagesPaise: totals.grossWages,
    totalEmployeeContributionPaise: totals.employeeContribution,
    totalEmployerContributionPaise: totals.employerContribution,
    totalContributionPaise: totals.total,
  };

  // Generate CSV content
  const csvContent = generateESIChallanCSV(summary, employees);
  const filename = `ESI_CHALLAN_${establishmentCode}_${payrollRun.year}${String(payrollRun.month).padStart(2, '0')}.csv`;

  return {
    summary,
    employees,
    csvContent,
    filename,
  };
}

/**
 * Generate ESI challan in CSV format
 */
function generateESIChallanCSV(
  summary: ESIChallanSummary,
  employees: ESIChallanEmployee[]
): string {
  const lines: string[] = [];

  // Header rows
  lines.push(`ESI Contribution Challan`);
  lines.push(`Establishment Code,${summary.establishmentCode}`);
  lines.push(`Establishment Name,${summary.establishmentName}`);
  lines.push(`Contribution Period,${summary.contributionPeriod}`);
  lines.push(`Total Employees,${summary.employeeCount}`);
  lines.push('');

  // Column headers
  lines.push('ESIC Number,Employee Name,Gross Wages,Employee Contribution (0.75%),Employer Contribution (3.25%),Total Contribution,IP Days');

  // Employee rows
  for (const emp of employees) {
    lines.push([
      emp.esicNumber,
      `"${emp.employeeName}"`,
      formatRupees(emp.grossWagesPaise),
      formatRupees(emp.employeeContributionPaise),
      formatRupees(emp.employerContributionPaise),
      formatRupees(emp.totalContributionPaise),
      emp.ipDays.toString(),
    ].join(','));
  }

  // Summary row
  lines.push('');
  lines.push([
    'TOTAL',
    '',
    formatRupees(summary.totalGrossWagesPaise),
    formatRupees(summary.totalEmployeeContributionPaise),
    formatRupees(summary.totalEmployerContributionPaise),
    formatRupees(summary.totalContributionPaise),
    '',
  ].join(','));

  return lines.join('\n');
}

function formatRupees(paise: number): string {
  return paiseToRupees(paise).toFixed(2);
}

/**
 * Check ESI eligibility for employee
 * ESI applies when gross <= Rs.21,000/month
 */
export function isESIEligible(grossSalaryPaise: number): boolean {
  const ESI_WAGE_CEILING_PAISE = 2100000; // Rs.21,000
  return grossSalaryPaise <= ESI_WAGE_CEILING_PAISE;
}

/**
 * Validate ESI employee data
 */
export function validateESIEmployee(emp: Partial<ESIChallanEmployee>): string[] {
  const errors: string[] = [];

  if (!emp.esicNumber || emp.esicNumber.length < 10) {
    errors.push('Invalid ESIC number');
  }

  if (!emp.employeeName || emp.employeeName.trim().length === 0) {
    errors.push('Employee name is required');
  }

  if (emp.ipDays !== undefined && (emp.ipDays < 0 || emp.ipDays > 31)) {
    errors.push('IP days must be between 0 and 31');
  }

  return errors;
}
```
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - generateESIChallan produces CSV with employee details
    - Summary totals are correct
    - Only ESI-applicable employees included
  </verify>
  <done>
    ESI challan generator created with CSV format, employee and employer contribution breakdown
  </done>
</task>

<task type="auto">
  <name>Task 3: Create statutory file download APIs</name>
  <files>
    src/app/api/payroll/[runId]/statutory/ecr/route.ts
    src/app/api/payroll/[runId]/statutory/esi/route.ts
  </files>
  <action>
1. Create src/app/api/payroll/[runId]/statutory/ecr/route.ts:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';
import { generateECRForPayrollRun } from '@/lib/statutory/file-generators/ecr';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';

// Company PF details - should be in config/database
const PF_ESTABLISHMENT_ID = 'KNBLR0000000';
const PF_ESTABLISHMENT_NAME = 'SHREEHR DEMO COMPANY';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ runId: string }> }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Only admin/payroll roles can download statutory files
  if (!['SUPER_ADMIN', 'ADMIN', 'PAYROLL_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { runId } = await params;

  // Verify payroll run exists and is completed
  const payrollRun = await prisma.payrollRun.findUnique({
    where: { id: runId },
  });

  if (!payrollRun) {
    return NextResponse.json({ error: 'Payroll run not found' }, { status: 404 });
  }

  if (payrollRun.status !== 'COMPLETED') {
    return NextResponse.json(
      { error: 'Payroll run is not completed' },
      { status: 400 }
    );
  }

  try {
    // Generate ECR file
    const ecr = await generateECRForPayrollRun(
      runId,
      PF_ESTABLISHMENT_ID,
      PF_ESTABLISHMENT_NAME
    );

    // Save to statutory files directory
    const statutoryDir = path.join(process.cwd(), 'uploads', 'statutory', runId);
    await mkdir(statutoryDir, { recursive: true });

    const filepath = path.join(statutoryDir, ecr.filename);
    await writeFile(filepath, ecr.content, 'utf-8');

    // Create/update statutory file record
    await prisma.statutoryFile.upsert({
      where: {
        payroll_run_id_type: {
          payroll_run_id: runId,
          type: 'ECR',
        },
      },
      create: {
        payroll_run_id: runId,
        type: 'ECR',
        filename: ecr.filename,
        filepath: filepath,
        file_size: Buffer.byteLength(ecr.content, 'utf-8'),
        record_count: ecr.recordCount,
        total_amount_paise: ecr.totalAmountPaise,
        generated_by: session.user.id,
      },
      update: {
        filename: ecr.filename,
        filepath: filepath,
        file_size: Buffer.byteLength(ecr.content, 'utf-8'),
        record_count: ecr.recordCount,
        total_amount_paise: ecr.totalAmountPaise,
        generated_at: new Date(),
        generated_by: session.user.id,
      },
    });

    // Return file for download
    return new Response(ecr.content, {
      headers: {
        'Content-Type': 'text/plain',
        'Content-Disposition': `attachment; filename="${ecr.filename}"`,
        'X-Record-Count': ecr.recordCount.toString(),
        'X-Total-Amount': (ecr.totalAmountPaise / 100).toFixed(2),
      },
    });
  } catch (error: any) {
    console.error('ECR generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate ECR file', details: error.message },
      { status: 500 }
    );
  }
}
```

2. Create src/app/api/payroll/[runId]/statutory/esi/route.ts:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';
import { generateESIChallan } from '@/lib/statutory/file-generators/esi-challan';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';

// Company ESI details - should be in config/database
const ESI_ESTABLISHMENT_CODE = 'KA00000000';
const ESI_ESTABLISHMENT_NAME = 'SHREEHR DEMO COMPANY';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ runId: string }> }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Only admin/payroll roles can download statutory files
  if (!['SUPER_ADMIN', 'ADMIN', 'PAYROLL_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { runId } = await params;

  // Verify payroll run exists and is completed
  const payrollRun = await prisma.payrollRun.findUnique({
    where: { id: runId },
  });

  if (!payrollRun) {
    return NextResponse.json({ error: 'Payroll run not found' }, { status: 404 });
  }

  if (payrollRun.status !== 'COMPLETED') {
    return NextResponse.json(
      { error: 'Payroll run is not completed' },
      { status: 400 }
    );
  }

  try {
    // Generate ESI challan
    const esi = await generateESIChallan(
      runId,
      ESI_ESTABLISHMENT_CODE,
      ESI_ESTABLISHMENT_NAME
    );

    if (esi.employees.length === 0) {
      return NextResponse.json(
        { message: 'No ESI-applicable employees in this payroll run' },
        { status: 200 }
      );
    }

    // Save to statutory files directory
    const statutoryDir = path.join(process.cwd(), 'uploads', 'statutory', runId);
    await mkdir(statutoryDir, { recursive: true });

    const filepath = path.join(statutoryDir, esi.filename);
    await writeFile(filepath, esi.csvContent, 'utf-8');

    // Create/update statutory file record
    await prisma.statutoryFile.upsert({
      where: {
        payroll_run_id_type: {
          payroll_run_id: runId,
          type: 'ESI_CHALLAN',
        },
      },
      create: {
        payroll_run_id: runId,
        type: 'ESI_CHALLAN',
        filename: esi.filename,
        filepath: filepath,
        file_size: Buffer.byteLength(esi.csvContent, 'utf-8'),
        record_count: esi.employees.length,
        total_amount_paise: esi.summary.totalContributionPaise,
        generated_by: session.user.id,
      },
      update: {
        filename: esi.filename,
        filepath: filepath,
        file_size: Buffer.byteLength(esi.csvContent, 'utf-8'),
        record_count: esi.employees.length,
        total_amount_paise: esi.summary.totalContributionPaise,
        generated_at: new Date(),
        generated_by: session.user.id,
      },
    });

    // Return file for download
    return new Response(esi.csvContent, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="${esi.filename}"`,
        'X-Record-Count': esi.employees.length.toString(),
        'X-Total-Amount': (esi.summary.totalContributionPaise / 100).toFixed(2),
      },
    });
  } catch (error: any) {
    console.error('ESI challan generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate ESI challan', details: error.message },
      { status: 500 }
    );
  }
}
```

3. Add unique constraint to StatutoryFile model in schema.prisma:
```prisma
  @@unique([payroll_run_id, type], name: "payroll_run_id_type")
```
  </action>
  <verify>
    - ECR download returns text file with #~# separators
    - ESI challan download returns CSV file
    - StatutoryFile record created on each download
    - RBAC enforced (only admin/payroll roles)
  </verify>
  <done>
    Statutory file download APIs created with ECR and ESI challan generation, file storage, and tracking
  </done>
</task>

</tasks>

<verification>
1. ECR file has correct EPFO format with #~# separators
2. ECR includes UAN, wages, all PF contribution components
3. ESI challan includes only employees with gross <= Rs.21,000
4. Files saved to uploads/statutory directory
5. StatutoryFile records track all generated files
</verification>

<success_criteria>
- [ ] ECR file format matches EPFO portal requirements
- [ ] ECR header line contains correct totals
- [ ] ESI challan includes employee and employer contributions
- [ ] Download APIs return files with correct Content-Type
- [ ] StatutoryFile model tracks generated files
- [ ] Only admin/payroll roles can download
</success_criteria>

<output>
After completion, create `.planning/phases/03-payroll-compliance/03-06-SUMMARY.md`
</output>
