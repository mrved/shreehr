---
phase: 03-payroll-compliance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/payroll/types.ts
  - src/lib/payroll/validators.ts
  - src/app/api/salary-structures/route.ts
  - src/app/api/salary-structures/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create salary structure with Basic, HRA, Special Allowance, LTA, Medical components"
    - "System validates that Basic Pay >= 50% of CTC before saving salary structure"
    - "Admin can update existing salary structure with effective date tracking"
    - "Invalid salary structures (Basic < 50%) are rejected with clear error message"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "SalaryStructure model with component fields in paise"
      contains: "model SalaryStructure"
    - path: "src/lib/payroll/validators.ts"
      provides: "50% Basic Pay Rule validation"
      exports: ["validate50PercentRule", "salaryStructureSchema"]
    - path: "src/app/api/salary-structures/route.ts"
      provides: "Salary structure CRUD API"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/salary-structures/route.ts"
      to: "src/lib/payroll/validators.ts"
      via: "validation before save"
      pattern: "validate50PercentRule"
    - from: "src/app/api/salary-structures/route.ts"
      to: "prisma.salaryStructure"
      via: "database operations"
      pattern: "prisma\\.salaryStructure\\.(create|findMany)"
---

<objective>
Create salary structure model and configuration API with 50% Basic Pay Rule validation

Purpose: Enable admin to configure employee salary structures that comply with Labour Code 2026 requirements. The 50% Basic Pay Rule is mandatory and affects PF/ESI calculations, so validation must be enforced before payroll processing.

Output:
- SalaryStructure model in Prisma schema
- Validation utilities for Labour Code compliance
- CRUD API for salary structure management
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payroll-compliance/03-RESEARCH.md
@prisma/schema.prisma
@src/lib/validations/employee.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SalaryStructure model and payroll types</name>
  <files>
    prisma/schema.prisma
    src/lib/payroll/types.ts
  </files>
  <action>
1. Add SalaryStructure model to schema.prisma:
   ```prisma
   model SalaryStructure {
     id          String   @id @default(cuid())
     employee_id String
     employee    Employee @relation(fields: [employee_id], references: [id], onDelete: Cascade)

     // Effective period
     effective_from DateTime @db.Date
     effective_to   DateTime? @db.Date

     // Salary components in paise (100 paise = 1 rupee)
     basic_paise             Int
     hra_paise               Int @default(0)
     special_allowance_paise Int @default(0)
     lta_paise               Int @default(0)
     medical_paise           Int @default(0)
     conveyance_paise        Int @default(0)
     other_allowances_paise  Int @default(0)

     // Computed fields stored for reference
     gross_monthly_paise Int // Sum of all components
     annual_ctc_paise    Int // gross * 12 + employer PF + employer ESI

     // Compliance validation
     basic_percentage    Float   // Basic as % of gross (must be >= 50)
     is_compliant        Boolean @default(true) // 50% rule compliance

     // Tax regime for TDS
     tax_regime TaxRegime @default(NEW)

     // Audit fields
     created_at DateTime @default(now())
     created_by String?
     creator    User?    @relation("SalaryStructureCreatedBy", fields: [created_by], references: [id])
     updated_at DateTime @updatedAt
     updated_by String?
     updater    User?    @relation("SalaryStructureUpdatedBy", fields: [updated_by], references: [id])

     @@index([employee_id])
     @@index([effective_from])
     @@map("salary_structures")
   }

   enum TaxRegime {
     OLD
     NEW
   }
   ```

2. Add relation to Employee model:
   ```prisma
   salary_structures SalaryStructure[]
   ```

3. Add User relations for audit:
   ```prisma
   created_salary_structures SalaryStructure[] @relation("SalaryStructureCreatedBy")
   updated_salary_structures SalaryStructure[] @relation("SalaryStructureUpdatedBy")
   ```

4. Create src/lib/payroll/types.ts with TypeScript interfaces:
   ```typescript
   export interface SalaryComponents {
     basic_paise: number;
     hra_paise: number;
     special_allowance_paise: number;
     lta_paise: number;
     medical_paise: number;
     conveyance_paise: number;
     other_allowances_paise: number;
   }

   export interface SalaryStructureInput extends SalaryComponents {
     employee_id: string;
     effective_from: Date;
     effective_to?: Date;
     tax_regime?: 'OLD' | 'NEW';
   }

   export interface ValidationResult {
     isValid: boolean;
     basicPercentage: number;
     grossMonthlyPaise: number;
     error?: string;
   }

   // Utility functions
   export function paiseToRupees(paise: number): number {
     return paise / 100;
   }

   export function rupeesToPaise(rupees: number): number {
     return Math.round(rupees * 100);
   }

   export function formatCurrency(paise: number): string {
     return new Intl.NumberFormat('en-IN', {
       style: 'currency',
       currency: 'INR',
       minimumFractionDigits: 0,
       maximumFractionDigits: 0,
     }).format(paiseToRupees(paise));
   }
   ```

Run `pnpm db:push` to update database schema.
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - `pnpm db:push` succeeds
    - SalaryStructure table created in database
  </verify>
  <done>
    SalaryStructure model exists with all component fields in paise, effective date tracking, and tax regime selection
  </done>
</task>

<task type="auto">
  <name>Task 2: Create 50% Basic Pay Rule validator</name>
  <files>
    src/lib/payroll/validators.ts
  </files>
  <action>
Create src/lib/payroll/validators.ts with Labour Code 2026 compliance validation:

```typescript
import { z } from 'zod';
import { type SalaryComponents, type ValidationResult } from './types';

// Minimum basic pay percentage per Labour Code 2026
const MIN_BASIC_PERCENTAGE = 50;

/**
 * Validates salary structure meets 50% Basic Pay Rule
 * Labour Code 2026 (effective Nov 21, 2025) requires:
 * Basic + DA + Retaining Allowance >= 50% of gross wages
 * For most companies without DA, this means Basic >= 50% of gross
 */
export function validate50PercentRule(components: SalaryComponents): ValidationResult {
  const grossMonthlyPaise =
    components.basic_paise +
    components.hra_paise +
    components.special_allowance_paise +
    components.lta_paise +
    components.medical_paise +
    components.conveyance_paise +
    components.other_allowances_paise;

  if (grossMonthlyPaise <= 0) {
    return {
      isValid: false,
      basicPercentage: 0,
      grossMonthlyPaise: 0,
      error: 'Total salary must be greater than zero'
    };
  }

  const basicPercentage = (components.basic_paise / grossMonthlyPaise) * 100;

  if (basicPercentage < MIN_BASIC_PERCENTAGE) {
    const requiredBasicPaise = Math.ceil(grossMonthlyPaise * (MIN_BASIC_PERCENTAGE / 100));
    const shortfallPaise = requiredBasicPaise - components.basic_paise;

    return {
      isValid: false,
      basicPercentage: Math.round(basicPercentage * 100) / 100,
      grossMonthlyPaise,
      error: `Basic pay (${basicPercentage.toFixed(2)}%) must be at least 50% of gross salary per Labour Code 2026. ` +
             `Increase basic by ${formatCurrencyShort(shortfallPaise)} or reduce allowances.`
    };
  }

  return {
    isValid: true,
    basicPercentage: Math.round(basicPercentage * 100) / 100,
    grossMonthlyPaise
  };
}

function formatCurrencyShort(paise: number): string {
  return `Rs.${(paise / 100).toLocaleString('en-IN')}`;
}

/**
 * Calculates annual CTC including employer contributions
 */
export function calculateAnnualCTC(grossMonthlyPaise: number, basicPaise: number): number {
  // Employer PF contribution (12% of basic, capped at Rs.15,000 basic)
  const PF_WAGE_CEILING_PAISE = 1500000; // Rs.15,000
  const pfBasePaise = Math.min(basicPaise, PF_WAGE_CEILING_PAISE);
  const employerPFMonthly = Math.round(pfBasePaise * 0.12);

  // Employer ESI contribution (3.25% if gross <= Rs.21,000)
  const ESI_WAGE_CEILING_PAISE = 2100000; // Rs.21,000
  const employerESIMonthly = grossMonthlyPaise <= ESI_WAGE_CEILING_PAISE
    ? Math.round(grossMonthlyPaise * 0.0325)
    : 0;

  // Annual CTC = (Gross + Employer PF + Employer ESI) * 12
  return (grossMonthlyPaise + employerPFMonthly + employerESIMonthly) * 12;
}

// Zod schema for API validation
export const salaryStructureSchema = z.object({
  employee_id: z.string().cuid(),
  effective_from: z.coerce.date(),
  effective_to: z.coerce.date().optional().nullable(),

  // All amounts in paise (integers)
  basic_paise: z.number().int().positive('Basic pay must be positive'),
  hra_paise: z.number().int().min(0).default(0),
  special_allowance_paise: z.number().int().min(0).default(0),
  lta_paise: z.number().int().min(0).default(0),
  medical_paise: z.number().int().min(0).default(0),
  conveyance_paise: z.number().int().min(0).default(0),
  other_allowances_paise: z.number().int().min(0).default(0),

  tax_regime: z.enum(['OLD', 'NEW']).default('NEW'),
}).refine((data) => {
  // Validate 50% rule
  const result = validate50PercentRule(data);
  return result.isValid;
}, {
  message: 'Salary structure does not meet 50% Basic Pay Rule (Labour Code 2026)',
  path: ['basic_paise']
});

export const salaryStructureUpdateSchema = salaryStructureSchema.partial().omit({ employee_id: true });
```
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - validate50PercentRule returns isValid: false when basic < 50%
    - validate50PercentRule returns isValid: true when basic >= 50%
  </verify>
  <done>
    50% Basic Pay Rule validator implemented with clear error messages including shortfall amount
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Salary Structure API endpoints</name>
  <files>
    src/app/api/salary-structures/route.ts
    src/app/api/salary-structures/[id]/route.ts
  </files>
  <action>
1. Create src/app/api/salary-structures/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';
import {
  salaryStructureSchema,
  validate50PercentRule,
  calculateAnnualCTC
} from '@/lib/payroll/validators';

// GET /api/salary-structures - List salary structures
// Query params: employee_id (optional), active_only (boolean)
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Only ADMIN, HR_MANAGER, PAYROLL_MANAGER can view salary structures
  const allowedRoles = ['SUPER_ADMIN', 'ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'];
  if (!allowedRoles.includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { searchParams } = new URL(request.url);
  const employeeId = searchParams.get('employee_id');
  const activeOnly = searchParams.get('active_only') === 'true';

  const where: any = {};

  if (employeeId) {
    where.employee_id = employeeId;
  }

  if (activeOnly) {
    const today = new Date();
    where.effective_from = { lte: today };
    where.OR = [
      { effective_to: null },
      { effective_to: { gte: today } }
    ];
  }

  const structures = await prisma.salaryStructure.findMany({
    where,
    include: {
      employee: {
        select: {
          id: true,
          employee_code: true,
          first_name: true,
          last_name: true,
          department: { select: { name: true } },
          designation: { select: { title: true } }
        }
      }
    },
    orderBy: [
      { employee_id: 'asc' },
      { effective_from: 'desc' }
    ]
  });

  return NextResponse.json({ data: structures });
}

// POST /api/salary-structures - Create salary structure
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Only ADMIN, HR_MANAGER, PAYROLL_MANAGER can create salary structures
  const allowedRoles = ['SUPER_ADMIN', 'ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'];
  if (!allowedRoles.includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  try {
    const body = await request.json();
    const validated = salaryStructureSchema.parse(body);

    // Verify employee exists
    const employee = await prisma.employee.findUnique({
      where: { id: validated.employee_id }
    });

    if (!employee) {
      return NextResponse.json(
        { error: 'Employee not found' },
        { status: 404 }
      );
    }

    // Calculate derived fields
    const validationResult = validate50PercentRule(validated);
    const annualCTC = calculateAnnualCTC(
      validationResult.grossMonthlyPaise,
      validated.basic_paise
    );

    // End previous active structure if exists
    await prisma.salaryStructure.updateMany({
      where: {
        employee_id: validated.employee_id,
        effective_to: null,
        effective_from: { lt: validated.effective_from }
      },
      data: {
        effective_to: new Date(validated.effective_from.getTime() - 86400000) // Day before
      }
    });

    // Create new structure
    const structure = await prisma.salaryStructure.create({
      data: {
        employee_id: validated.employee_id,
        effective_from: validated.effective_from,
        effective_to: validated.effective_to,

        basic_paise: validated.basic_paise,
        hra_paise: validated.hra_paise,
        special_allowance_paise: validated.special_allowance_paise,
        lta_paise: validated.lta_paise,
        medical_paise: validated.medical_paise,
        conveyance_paise: validated.conveyance_paise,
        other_allowances_paise: validated.other_allowances_paise,

        gross_monthly_paise: validationResult.grossMonthlyPaise,
        annual_ctc_paise: annualCTC,
        basic_percentage: validationResult.basicPercentage,
        is_compliant: validationResult.isValid,

        tax_regime: validated.tax_regime,

        created_by: session.user.id,
        updated_by: session.user.id
      },
      include: {
        employee: {
          select: {
            employee_code: true,
            first_name: true,
            last_name: true
          }
        }
      }
    });

    return NextResponse.json({ data: structure }, { status: 201 });

  } catch (error: any) {
    if (error.name === 'ZodError') {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }

    console.error('Create salary structure error:', error);
    return NextResponse.json(
      { error: 'Failed to create salary structure' },
      { status: 500 }
    );
  }
}
```

2. Create src/app/api/salary-structures/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';
import {
  salaryStructureUpdateSchema,
  validate50PercentRule,
  calculateAnnualCTC
} from '@/lib/payroll/validators';

// GET /api/salary-structures/[id] - Get single salary structure
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const allowedRoles = ['SUPER_ADMIN', 'ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'];
  if (!allowedRoles.includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;

  const structure = await prisma.salaryStructure.findUnique({
    where: { id },
    include: {
      employee: {
        select: {
          id: true,
          employee_code: true,
          first_name: true,
          last_name: true,
          department: { select: { name: true } },
          designation: { select: { title: true } }
        }
      }
    }
  });

  if (!structure) {
    return NextResponse.json({ error: 'Salary structure not found' }, { status: 404 });
  }

  return NextResponse.json({ data: structure });
}

// PATCH /api/salary-structures/[id] - Update salary structure
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const allowedRoles = ['SUPER_ADMIN', 'ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'];
  if (!allowedRoles.includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;

  try {
    const existing = await prisma.salaryStructure.findUnique({
      where: { id }
    });

    if (!existing) {
      return NextResponse.json({ error: 'Salary structure not found' }, { status: 404 });
    }

    const body = await request.json();
    const validated = salaryStructureUpdateSchema.parse(body);

    // Merge with existing values for validation
    const merged = {
      basic_paise: validated.basic_paise ?? existing.basic_paise,
      hra_paise: validated.hra_paise ?? existing.hra_paise,
      special_allowance_paise: validated.special_allowance_paise ?? existing.special_allowance_paise,
      lta_paise: validated.lta_paise ?? existing.lta_paise,
      medical_paise: validated.medical_paise ?? existing.medical_paise,
      conveyance_paise: validated.conveyance_paise ?? existing.conveyance_paise,
      other_allowances_paise: validated.other_allowances_paise ?? existing.other_allowances_paise,
    };

    // Validate 50% rule with merged values
    const validationResult = validate50PercentRule(merged);

    if (!validationResult.isValid) {
      return NextResponse.json(
        { error: validationResult.error },
        { status: 400 }
      );
    }

    const annualCTC = calculateAnnualCTC(
      validationResult.grossMonthlyPaise,
      merged.basic_paise
    );

    const updated = await prisma.salaryStructure.update({
      where: { id },
      data: {
        ...validated,
        gross_monthly_paise: validationResult.grossMonthlyPaise,
        annual_ctc_paise: annualCTC,
        basic_percentage: validationResult.basicPercentage,
        is_compliant: validationResult.isValid,
        updated_by: session.user.id
      },
      include: {
        employee: {
          select: {
            employee_code: true,
            first_name: true,
            last_name: true
          }
        }
      }
    });

    return NextResponse.json({ data: updated });

  } catch (error: any) {
    if (error.name === 'ZodError') {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }

    console.error('Update salary structure error:', error);
    return NextResponse.json(
      { error: 'Failed to update salary structure' },
      { status: 500 }
    );
  }
}

// DELETE /api/salary-structures/[id] - Delete salary structure
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Only ADMIN can delete salary structures
  const allowedRoles = ['SUPER_ADMIN', 'ADMIN'];
  if (!allowedRoles.includes(session.user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;

  const existing = await prisma.salaryStructure.findUnique({
    where: { id }
  });

  if (!existing) {
    return NextResponse.json({ error: 'Salary structure not found' }, { status: 404 });
  }

  // Check if salary structure has been used in payroll
  // (Will add this check when PayrollRecord model exists)

  await prisma.salaryStructure.delete({
    where: { id }
  });

  return NextResponse.json({ message: 'Salary structure deleted' });
}
```
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - POST /api/salary-structures with basic < 50% returns 400 error
    - POST /api/salary-structures with basic >= 50% returns 201 with created structure
    - GET /api/salary-structures returns list of structures
  </verify>
  <done>
    Salary structure CRUD API with 50% Basic Pay Rule validation enforced on create and update
  </done>
</task>

</tasks>

<verification>
1. Database: SalaryStructure table exists with correct columns
2. Validation: 50% rule rejects non-compliant structures with clear error message
3. API: All CRUD operations work with proper RBAC enforcement
4. Effective dates: Creating new structure ends previous active structure
</verification>

<success_criteria>
- [ ] SalaryStructure model added to Prisma schema
- [ ] validate50PercentRule function correctly validates Labour Code 2026 compliance
- [ ] API endpoints enforce RBAC (ADMIN/HR_MANAGER/PAYROLL_MANAGER only)
- [ ] Creating salary structure with Basic < 50% fails with descriptive error
- [ ] Tax regime can be set per employee (OLD/NEW)
</success_criteria>

<output>
After completion, create `.planning/phases/03-payroll-compliance/03-01-SUMMARY.md`
</output>
