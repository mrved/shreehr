---
phase: 03-payroll-compliance
plan: 04
type: tdd
wave: 2
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - src/lib/payroll/calculator.ts
  - src/lib/payroll/calculator.test.ts
  - src/lib/statutory/pf.ts
  - src/lib/statutory/pf.test.ts
  - src/lib/statutory/esi.ts
  - src/lib/statutory/tds.ts
  - src/lib/queues/workers/payroll.worker.ts
autonomous: true

must_haves:
  truths:
    - "System calculates gross salary from salary structure components"
    - "System calculates LOP deduction based on attendance data"
    - "System calculates PF with correct wage ceiling cap (Rs.15,000)"
    - "System calculates employer PF breakdown (3.67% EPF, 8.33% EPS capped at Rs.1,250)"
    - "System calculates ESI only when gross <= Rs.21,000"
    - "System calculates PT using configured state slabs"
    - "System calculates TDS based on projected annual income and tax regime"
  artifacts:
    - path: "src/lib/payroll/calculator.ts"
      provides: "Core payroll calculation functions"
      exports: ["calculateGrossSalary", "calculateLOP", "calculateNetSalary"]
    - path: "src/lib/statutory/pf.ts"
      provides: "PF calculation with employer breakdown"
      exports: ["calculatePF", "calculateEmployerPFBreakdown"]
    - path: "src/lib/statutory/esi.ts"
      provides: "ESI calculation with wage ceiling check"
      exports: ["calculateESI", "isESIApplicable"]
    - path: "src/lib/statutory/tds.ts"
      provides: "TDS calculation with regime support"
      exports: ["calculateMonthlyTDS", "calculateAnnualTax"]
  key_links:
    - from: "src/lib/queues/workers/payroll.worker.ts"
      to: "src/lib/payroll/calculator.ts"
      via: "calculation stage"
      pattern: "calculateNetSalary"
    - from: "src/lib/payroll/calculator.ts"
      to: "src/lib/statutory/pf.ts"
      via: "PF deduction"
      pattern: "calculatePF"
---

<objective>
Implement payroll calculation engine with Indian statutory compliance using TDD

Purpose: The calculation engine is the core of payroll processing. Each statutory deduction (PF, ESI, PT, TDS) has specific rules, caps, and edge cases. TDD ensures calculations are correct before integration.

Output:
- Tested calculation functions for gross, LOP, deductions
- Statutory compliance calculations (PF, ESI, PT, TDS)
- Complete payroll worker implementation
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payroll-compliance/03-RESEARCH.md
@.planning/phases/03-payroll-compliance/03-01-SUMMARY.md
@.planning/phases/03-payroll-compliance/03-02-SUMMARY.md
@.planning/phases/03-payroll-compliance/03-03-SUMMARY.md
@src/lib/payroll/types.ts
@src/lib/payroll/constants.ts
@src/lib/statutory/pt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PF calculation with TDD</name>
  <files>
    src/lib/statutory/pf.ts
    src/lib/statutory/pf.test.ts
  </files>
  <action>
**RED Phase: Write failing tests first**

Create src/lib/statutory/pf.test.ts:
```typescript
import { describe, it, expect } from 'vitest';
import {
  calculatePF,
  calculateEmployerPFBreakdown,
  PF_WAGE_CEILING_PAISE,
  EPS_MAX_MONTHLY_PAISE
} from './pf';

describe('PF Calculation', () => {
  describe('calculatePF', () => {
    it('should calculate 12% employee PF for basic under ceiling', () => {
      // Basic: Rs.12,000 = 1,200,000 paise
      const result = calculatePF(1200000);
      expect(result.employeePF).toBe(144000); // 12% of 12,000 = 1,440
    });

    it('should cap PF at wage ceiling for high basic', () => {
      // Basic: Rs.25,000 = 2,500,000 paise
      // PF base should be capped at Rs.15,000
      const result = calculatePF(2500000);
      expect(result.pfBase).toBe(1500000); // Rs.15,000
      expect(result.employeePF).toBe(180000); // 12% of 15,000 = 1,800
    });

    it('should handle exact wage ceiling amount', () => {
      const result = calculatePF(1500000); // Rs.15,000 exactly
      expect(result.pfBase).toBe(1500000);
      expect(result.employeePF).toBe(180000);
    });

    it('should handle zero basic', () => {
      const result = calculatePF(0);
      expect(result.employeePF).toBe(0);
      expect(result.pfBase).toBe(0);
    });
  });

  describe('calculateEmployerPFBreakdown', () => {
    it('should correctly split employer contribution', () => {
      // Basic: Rs.12,000 = 1,200,000 paise
      const result = calculateEmployerPFBreakdown(1200000);

      // 3.67% EPF
      expect(result.epf).toBe(44040); // 3.67% of 12,000 = 440.40

      // 8.33% EPS (not capped because 8.33% of 12,000 = 999.60 < 1,250)
      expect(result.eps).toBe(99960);

      // 0.50% EDLI
      expect(result.edli).toBe(6000);

      // Total employer = EPF + EPS + EDLI (without admin for simplicity)
      expect(result.total).toBeGreaterThan(0);
    });

    it('should cap EPS at Rs.1,250 for high basic', () => {
      // Basic: Rs.25,000 = 2,500,000 paise (but PF base is 15,000)
      // EPS should be capped at Rs.1,250 = 125,000 paise
      const result = calculateEmployerPFBreakdown(2500000);

      expect(result.eps).toBe(125000); // Capped at Rs.1,250

      // EPF gets the difference: Total employer 12% of 15,000 = 1,800
      // EPS capped at 1,250, EDLI = 75, so EPF = 1,800 - 1,250 - 75 = 475?
      // Actually: EPF = 3.67% of base = 550.50, then adjustment
    });

    it('should return all zero for zero basic', () => {
      const result = calculateEmployerPFBreakdown(0);
      expect(result.epf).toBe(0);
      expect(result.eps).toBe(0);
      expect(result.edli).toBe(0);
      expect(result.total).toBe(0);
    });
  });
});
```

**GREEN Phase: Implement to pass tests**

Create src/lib/statutory/pf.ts:
```typescript
import {
  PF_WAGE_CEILING_PAISE,
  PF_EMPLOYEE_RATE,
  EPF_EMPLOYER_RATE,
  EPS_RATE,
  EDLI_RATE,
  EPS_MAX_MONTHLY_PAISE,
  PF_ADMIN_RATE,
} from '@/lib/payroll/constants';

export {
  PF_WAGE_CEILING_PAISE,
  EPS_MAX_MONTHLY_PAISE,
};

export interface PFCalculationResult {
  pfBase: number;          // min(basic, ceiling) in paise
  employeePF: number;      // Employee's 12% contribution
  employerTotal: number;   // Total employer contribution
  breakdown: {
    epf: number;           // 3.67% to EPF
    eps: number;           // 8.33% to EPS (capped at Rs.1,250)
    edli: number;          // 0.50% to EDLI
    adminCharges: number;  // 0.51% admin charges
  };
}

/**
 * Calculate PF contributions for an employee
 *
 * @param basicSalaryPaise - Monthly basic salary in paise
 * @returns PF calculation result with all components
 */
export function calculatePF(basicSalaryPaise: number): PFCalculationResult {
  if (basicSalaryPaise <= 0) {
    return {
      pfBase: 0,
      employeePF: 0,
      employerTotal: 0,
      breakdown: { epf: 0, eps: 0, edli: 0, adminCharges: 0 },
    };
  }

  // Apply wage ceiling
  const pfBase = Math.min(basicSalaryPaise, PF_WAGE_CEILING_PAISE);

  // Employee contribution: 12% of PF base
  const employeePF = Math.round(pfBase * PF_EMPLOYEE_RATE);

  // Get employer breakdown
  const breakdown = calculateEmployerPFBreakdown(basicSalaryPaise);

  return {
    pfBase,
    employeePF,
    employerTotal: breakdown.total,
    breakdown,
  };
}

export interface EmployerPFBreakdown {
  epf: number;           // 3.67%
  eps: number;           // 8.33% capped at Rs.1,250
  edli: number;          // 0.50%
  adminCharges: number;  // 0.51%
  total: number;
}

/**
 * Calculate employer PF contribution breakdown
 *
 * Employer's 12% is split into:
 * - 3.67% to Employee Provident Fund (EPF)
 * - 8.33% to Employee Pension Scheme (EPS) - capped at Rs.1,250/month
 * - 0.50% to Employee Deposit Linked Insurance (EDLI)
 * - 0.50% + 0.01% admin charges
 *
 * When EPS caps at Rs.1,250, the difference goes to EPF
 */
export function calculateEmployerPFBreakdown(basicSalaryPaise: number): EmployerPFBreakdown {
  if (basicSalaryPaise <= 0) {
    return { epf: 0, eps: 0, edli: 0, adminCharges: 0, total: 0 };
  }

  // Apply wage ceiling
  const pfBase = Math.min(basicSalaryPaise, PF_WAGE_CEILING_PAISE);

  // Calculate each component
  let eps = Math.round(pfBase * EPS_RATE);

  // Cap EPS at Rs.1,250
  if (eps > EPS_MAX_MONTHLY_PAISE) {
    eps = EPS_MAX_MONTHLY_PAISE;
  }

  // EDLI: 0.50%
  const edli = Math.round(pfBase * EDLI_RATE);

  // Admin charges: 0.51%
  const adminCharges = Math.round(pfBase * PF_ADMIN_RATE);

  // EPF: Total employer PF (12%) minus EPS and EDLI
  // This ensures the total is correct even with EPS cap
  const totalEmployerPF = Math.round(pfBase * PF_EMPLOYEE_RATE);
  const epf = totalEmployerPF - eps - edli;

  const total = epf + eps + edli + adminCharges;

  return { epf, eps, edli, adminCharges, total };
}

/**
 * Check if employee is eligible for PF
 * All employees with basic >= Rs.15,000 are mandatorily covered
 * Employees with basic < Rs.15,000 can opt out (but most don't)
 */
export function isPFMandatory(basicSalaryPaise: number): boolean {
  return basicSalaryPaise >= PF_WAGE_CEILING_PAISE;
}
```

Run tests: `pnpm test src/lib/statutory/pf.test.ts`
  </action>
  <verify>
    - All PF tests pass
    - Employee PF is 12% of min(basic, 15000)
    - EPS caps at Rs.1,250
    - Employer breakdown sums correctly
  </verify>
  <done>
    PF calculation implemented with wage ceiling cap and employer contribution breakdown (EPF/EPS/EDLI split)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ESI and TDS calculations</name>
  <files>
    src/lib/statutory/esi.ts
    src/lib/statutory/tds.ts
  </files>
  <action>
1. Create src/lib/statutory/esi.ts:
```typescript
import {
  ESI_EMPLOYEE_RATE,
  ESI_EMPLOYER_RATE,
  ESI_WAGE_CEILING_PAISE,
} from '@/lib/payroll/constants';

export interface ESICalculationResult {
  applicable: boolean;
  employeeESI: number;   // 0.75% of gross
  employerESI: number;   // 3.25% of gross
  grossUsed: number;     // Gross salary used for calculation
  reason?: string;
}

/**
 * Check if ESI is applicable for the employee
 * ESI applies when gross salary <= Rs.21,000/month
 */
export function isESIApplicable(grossSalaryPaise: number): boolean {
  return grossSalaryPaise <= ESI_WAGE_CEILING_PAISE;
}

/**
 * Calculate ESI contributions
 *
 * @param grossSalaryPaise - Monthly gross salary in paise
 * @returns ESI calculation result
 */
export function calculateESI(grossSalaryPaise: number): ESICalculationResult {
  if (!isESIApplicable(grossSalaryPaise)) {
    return {
      applicable: false,
      employeeESI: 0,
      employerESI: 0,
      grossUsed: grossSalaryPaise,
      reason: `Gross salary Rs.${(grossSalaryPaise / 100).toLocaleString()} exceeds ESI ceiling of Rs.21,000`,
    };
  }

  const employeeESI = Math.round(grossSalaryPaise * ESI_EMPLOYEE_RATE);
  const employerESI = Math.round(grossSalaryPaise * ESI_EMPLOYER_RATE);

  return {
    applicable: true,
    employeeESI,
    employerESI,
    grossUsed: grossSalaryPaise,
  };
}

/**
 * Check if employee was ESI-covered in previous period
 * Once covered, employee remains covered for the contribution period
 * even if salary exceeds limit
 */
export async function checkESIContinuity(
  employeeId: string,
  month: number,
  year: number
): Promise<boolean> {
  // ESI contribution periods:
  // April - September (contribution period 1)
  // October - March (contribution period 2)

  // Determine contribution period start
  let periodStartMonth: number;
  let periodStartYear: number;

  if (month >= 4 && month <= 9) {
    // Period 1: April-September
    periodStartMonth = 4;
    periodStartYear = year;
  } else if (month >= 10) {
    // Period 2: October-March (Oct-Dec)
    periodStartMonth = 10;
    periodStartYear = year;
  } else {
    // Period 2: October-March (Jan-Mar)
    periodStartMonth = 10;
    periodStartYear = year - 1;
  }

  // TODO: Query previous payroll records to check if ESI was deducted
  // For now, return false (check fresh each month)
  return false;
}
```

2. Create src/lib/statutory/tds.ts:
```typescript
import { TDS_STANDARD_DEDUCTION_PAISE } from '@/lib/payroll/constants';

export interface TDSCalculationResult {
  monthlyTDS: number;           // Monthly TDS to deduct
  projectedAnnualIncome: number; // Projected annual taxable income
  projectedAnnualTax: number;   // Projected annual tax
  regime: 'OLD' | 'NEW';
  breakdown?: {
    grossIncome: number;
    standardDeduction: number;
    taxableIncome: number;
    taxBeforeCess: number;
    cessPaise: number;
  };
}

// New Tax Regime Slabs FY 2025-26 (Budget 2024)
const NEW_REGIME_SLABS = [
  { min: 0, max: 300000, rate: 0 },           // Up to 3L - Nil
  { min: 300000, max: 700000, rate: 0.05 },   // 3L - 7L - 5%
  { min: 700000, max: 1000000, rate: 0.10 },  // 7L - 10L - 10%
  { min: 1000000, max: 1200000, rate: 0.15 }, // 10L - 12L - 15%
  { min: 1200000, max: 1500000, rate: 0.20 }, // 12L - 15L - 20%
  { min: 1500000, max: Infinity, rate: 0.30 }, // Above 15L - 30%
];

// Old Tax Regime Slabs FY 2025-26
const OLD_REGIME_SLABS = [
  { min: 0, max: 250000, rate: 0 },           // Up to 2.5L - Nil
  { min: 250000, max: 500000, rate: 0.05 },   // 2.5L - 5L - 5%
  { min: 500000, max: 1000000, rate: 0.20 },  // 5L - 10L - 20%
  { min: 1000000, max: Infinity, rate: 0.30 }, // Above 10L - 30%
];

// Standard deduction: Rs.75,000 for new regime (Budget 2024)
const STANDARD_DEDUCTION_NEW_REGIME = 7500000; // In paise
const STANDARD_DEDUCTION_OLD_REGIME = 5000000; // Rs.50,000 for old regime

// New regime rebate: Full tax rebate if income <= Rs.7L
const NEW_REGIME_REBATE_LIMIT = 700000; // Rs.7L (in rupees for comparison)

/**
 * Calculate monthly TDS based on projected annual income
 *
 * @param monthlyGrossPaise - Monthly gross salary in paise
 * @param currentMonth - Current month (1-12)
 * @param regime - Tax regime ('OLD' or 'NEW')
 * @param yearToDateTDS - TDS already deducted this FY (optional)
 * @returns TDS calculation result
 */
export function calculateMonthlyTDS(
  monthlyGrossPaise: number,
  currentMonth: number,
  regime: 'OLD' | 'NEW' = 'NEW',
  yearToDateTDS: number = 0
): TDSCalculationResult {
  // Calculate remaining months in FY
  // FY runs April (month 4) to March (month 3)
  const fyStartMonth = 4;
  const currentFYMonth = currentMonth >= fyStartMonth
    ? currentMonth - fyStartMonth + 1  // Apr=1, May=2, ..., Mar=12
    : currentMonth + (12 - fyStartMonth + 1);  // Jan=10, Feb=11, Mar=12

  const remainingMonths = 12 - currentFYMonth + 1;
  const pastMonths = currentFYMonth - 1;

  // Project annual income
  const projectedAnnualIncome = monthlyGrossPaise * 12;

  // Apply standard deduction based on regime
  const standardDeduction = regime === 'NEW'
    ? STANDARD_DEDUCTION_NEW_REGIME
    : STANDARD_DEDUCTION_OLD_REGIME;

  const taxableIncome = Math.max(0, projectedAnnualIncome - standardDeduction);

  // Calculate annual tax
  const taxBeforeCess = calculateTaxFromSlabs(
    taxableIncome / 100, // Convert to rupees for slab comparison
    regime === 'NEW' ? NEW_REGIME_SLABS : OLD_REGIME_SLABS
  ) * 100; // Convert back to paise

  // Check for rebate (new regime only)
  let finalTax = taxBeforeCess;
  if (regime === 'NEW' && (projectedAnnualIncome / 100) <= NEW_REGIME_REBATE_LIMIT) {
    finalTax = 0;
  }

  // Add 4% health and education cess
  const cessPaise = Math.round(finalTax * 0.04);
  const projectedAnnualTax = finalTax + cessPaise;

  // Calculate monthly TDS
  // Spread remaining tax over remaining months
  const remainingTax = Math.max(0, projectedAnnualTax - yearToDateTDS);
  const monthlyTDS = remainingMonths > 0
    ? Math.round(remainingTax / remainingMonths)
    : 0;

  return {
    monthlyTDS,
    projectedAnnualIncome,
    projectedAnnualTax,
    regime,
    breakdown: {
      grossIncome: projectedAnnualIncome,
      standardDeduction,
      taxableIncome,
      taxBeforeCess: finalTax,
      cessPaise,
    },
  };
}

/**
 * Calculate tax from slab rates
 */
function calculateTaxFromSlabs(
  incomeRupees: number,
  slabs: typeof NEW_REGIME_SLABS
): number {
  let tax = 0;
  let remainingIncome = incomeRupees;

  for (const slab of slabs) {
    if (remainingIncome <= 0) break;

    const slabWidth = slab.max === Infinity
      ? remainingIncome
      : Math.min(remainingIncome, slab.max - slab.min);

    if (slabWidth > 0) {
      tax += slabWidth * slab.rate;
      remainingIncome -= slabWidth;
    }
  }

  return Math.round(tax);
}

/**
 * Calculate annual tax for a given income (for planning purposes)
 */
export function calculateAnnualTax(
  annualIncomePaise: number,
  regime: 'OLD' | 'NEW' = 'NEW'
): number {
  const standardDeduction = regime === 'NEW'
    ? STANDARD_DEDUCTION_NEW_REGIME
    : STANDARD_DEDUCTION_OLD_REGIME;

  const taxableIncome = Math.max(0, annualIncomePaise - standardDeduction);

  const taxBeforeCess = calculateTaxFromSlabs(
    taxableIncome / 100,
    regime === 'NEW' ? NEW_REGIME_SLABS : OLD_REGIME_SLABS
  ) * 100;

  // Check for rebate
  let finalTax = taxBeforeCess;
  if (regime === 'NEW' && (annualIncomePaise / 100) <= NEW_REGIME_REBATE_LIMIT) {
    finalTax = 0;
  }

  // Add cess
  const cess = Math.round(finalTax * 0.04);

  return finalTax + cess;
}
```
  </action>
  <verify>
    - ESI returns 0 when gross > Rs.21,000
    - ESI calculates 0.75% employee and 3.25% employer
    - TDS applies correct slabs for new/old regime
    - TDS includes 4% cess
  </verify>
  <done>
    ESI and TDS calculation utilities implemented with wage ceiling check, regime support, and standard deduction
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement payroll calculator and complete worker</name>
  <files>
    src/lib/payroll/calculator.ts
    src/lib/queues/workers/payroll.worker.ts
  </files>
  <action>
1. Create src/lib/payroll/calculator.ts:
```typescript
import { prisma } from '@/lib/db';
import { type SalaryComponents } from './types';
import { calculatePF } from '@/lib/statutory/pf';
import { calculateESI } from '@/lib/statutory/esi';
import { calculatePT } from '@/lib/statutory/pt';
import { calculateMonthlyTDS } from '@/lib/statutory/tds';

export interface PayrollCalculationInput {
  employeeId: string;
  month: number;
  year: number;
  salaryStructure: {
    basic_paise: number;
    hra_paise: number;
    special_allowance_paise: number;
    lta_paise: number;
    medical_paise: number;
    conveyance_paise: number;
    other_allowances_paise: number;
    tax_regime: 'OLD' | 'NEW';
  };
  attendance: {
    workingDays: number;
    paidDays: number;
    lopDays: number;
  };
  workState: string;
  gender?: string;
}

export interface PayrollCalculationResult {
  // Gross calculation
  grossBeforeLOP: number;
  lopDeduction: number;
  grossSalary: number;

  // Statutory deductions
  pfEmployee: number;
  pfEmployerBreakdown: {
    epf: number;
    eps: number;
    edli: number;
    adminCharges: number;
    total: number;
  };
  pfBase: number;

  esiEmployee: number;
  esiEmployer: number;
  esiApplicable: boolean;

  ptAmount: number;

  tdsAmount: number;
  projectedAnnualIncome: number;
  taxRegime: 'OLD' | 'NEW';

  // Totals
  totalDeductions: number;
  netSalary: number;
  employerCost: number;
}

/**
 * Calculate gross salary from components
 */
export function calculateGrossSalary(components: SalaryComponents): number {
  return (
    components.basic_paise +
    components.hra_paise +
    components.special_allowance_paise +
    components.lta_paise +
    components.medical_paise +
    components.conveyance_paise +
    components.other_allowances_paise
  );
}

/**
 * Calculate LOP (Loss of Pay) deduction
 *
 * LOP = (Monthly Gross / Working Days) * LOP Days
 */
export function calculateLOP(
  grossMonthlyPaise: number,
  workingDays: number,
  lopDays: number
): number {
  if (workingDays <= 0 || lopDays <= 0) return 0;

  const perDayPaise = Math.round(grossMonthlyPaise / workingDays);
  return perDayPaise * lopDays;
}

/**
 * Calculate complete payroll for an employee
 */
export async function calculatePayroll(
  input: PayrollCalculationInput
): Promise<PayrollCalculationResult> {
  const { salaryStructure, attendance, workState, gender, month } = input;

  // 1. Calculate gross before LOP
  const grossBeforeLOP = calculateGrossSalary(salaryStructure);

  // 2. Calculate LOP deduction
  const lopDeduction = calculateLOP(
    grossBeforeLOP,
    attendance.workingDays,
    attendance.lopDays
  );

  // 3. Gross after LOP
  const grossSalary = grossBeforeLOP - lopDeduction;

  // 4. Calculate PF (on basic, not gross)
  const pfResult = calculatePF(salaryStructure.basic_paise);

  // 5. Calculate ESI (on gross)
  const esiResult = calculateESI(grossSalary);

  // 6. Calculate PT
  const ptResult = await calculatePT(workState, grossSalary, month, gender);
  const ptAmount = ptResult.applicable ? ptResult.monthlyPTpaise : 0;

  // 7. Calculate TDS
  const tdsResult = calculateMonthlyTDS(
    grossSalary,
    month,
    salaryStructure.tax_regime
  );

  // 8. Total deductions (employee side)
  const totalDeductions =
    pfResult.employeePF +
    esiResult.employeeESI +
    ptAmount +
    tdsResult.monthlyTDS;

  // 9. Net salary
  const netSalary = grossSalary - totalDeductions;

  // 10. Employer cost
  const employerCost =
    grossSalary +
    pfResult.employerTotal +
    esiResult.employerESI;

  return {
    grossBeforeLOP,
    lopDeduction,
    grossSalary,

    pfEmployee: pfResult.employeePF,
    pfEmployerBreakdown: pfResult.breakdown,
    pfBase: pfResult.pfBase,

    esiEmployee: esiResult.employeeESI,
    esiEmployer: esiResult.employerESI,
    esiApplicable: esiResult.applicable,

    ptAmount,

    tdsAmount: tdsResult.monthlyTDS,
    projectedAnnualIncome: tdsResult.projectedAnnualIncome,
    taxRegime: salaryStructure.tax_regime,

    totalDeductions,
    netSalary,
    employerCost,
  };
}

/**
 * Get attendance summary for payroll
 */
export async function getAttendanceSummary(
  employeeId: string,
  month: number,
  year: number
): Promise<{
  workingDays: number;
  presentDays: number;
  lopDays: number;
  paidDays: number;
}> {
  // Get attendance records for the month
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0);

  const attendances = await prisma.attendance.findMany({
    where: {
      employee_id: employeeId,
      date: {
        gte: startDate,
        lte: endDate,
      },
    },
  });

  // Calculate working days (exclude weekends)
  let workingDays = 0;
  let currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const dayOfWeek = currentDate.getDay();
    if (dayOfWeek !== 0 && dayOfWeek !== 6) {
      workingDays++;
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Count attendance statuses
  let presentDays = 0;
  let lopDays = 0;

  for (const att of attendances) {
    if (att.status === 'PRESENT') {
      presentDays += 1;
    } else if (att.status === 'HALF_DAY') {
      presentDays += 0.5;
    } else if (att.status === 'ON_LEAVE') {
      // Check if paid leave
      // For now, count as present (paid)
      presentDays += 1;
    } else if (att.status === 'ABSENT') {
      lopDays += 1;
    }
    // HOLIDAY and WEEKEND don't count either way
  }

  // Paid days = Present days + any paid leave
  const paidDays = workingDays - lopDays;

  return {
    workingDays,
    presentDays: Math.round(presentDays),
    lopDays,
    paidDays: Math.max(0, paidDays),
  };
}
```

2. Update src/lib/queues/workers/payroll.worker.ts with full implementation:
```typescript
import { Worker, Job } from 'bullmq';
import { getQueueConnection } from '../connection';
import { PayrollJobData, PayrollJobResult, addPayrollJob } from '../payroll.queue';
import { prisma } from '@/lib/db';
import {
  calculatePayroll,
  getAttendanceSummary,
} from '@/lib/payroll/calculator';

/**
 * Create and start the payroll worker
 */
export function createPayrollWorker(): Worker<PayrollJobData, PayrollJobResult> {
  const worker = new Worker<PayrollJobData, PayrollJobResult>(
    'payroll',
    async (job: Job<PayrollJobData, PayrollJobResult>) => {
      console.log(`Processing payroll job: ${job.id}, stage: ${job.data.stage}`);

      const { payrollRunId, stage } = job.data;

      // Update PayrollRun status
      await prisma.payrollRun.update({
        where: { id: payrollRunId },
        data: {
          status: 'PROCESSING',
          current_stage: stage.toUpperCase() as any,
          ...(stage === 'validation' ? { started_at: new Date() } : {}),
        },
      });

      try {
        let result: PayrollJobResult;

        switch (stage) {
          case 'validation':
            result = await processValidationStage(job);
            break;
          case 'calculation':
            result = await processCalculationStage(job);
            break;
          case 'statutory':
            result = await processStatutoryStage(job);
            break;
          case 'finalization':
            result = await processFinalizationStage(job);
            break;
          default:
            throw new Error(`Unknown stage: ${stage}`);
        }

        // Queue next stage if applicable
        if (result.success && result.nextStage) {
          await addPayrollJob({
            payrollRunId,
            month: job.data.month,
            year: job.data.year,
            stage: result.nextStage,
          });
        }

        return result;
      } catch (error: any) {
        await prisma.payrollRun.update({
          where: { id: payrollRunId },
          data: {
            status: 'FAILED',
            errors: [{ stage, message: error.message }],
          },
        });

        throw error;
      }
    },
    {
      ...getQueueConnection(),
      concurrency: 1,
    }
  );

  worker.on('completed', (job, result) => {
    console.log(`Payroll job ${job.id} completed:`, result);
  });

  worker.on('failed', (job, error) => {
    console.error(`Payroll job ${job?.id} failed:`, error.message);
  });

  return worker;
}

async function processValidationStage(
  job: Job<PayrollJobData, PayrollJobResult>
): Promise<PayrollJobResult> {
  const { payrollRunId, month, year } = job.data;
  const errors: Array<{ employeeId: string; message: string }> = [];

  // 1. Check attendance lock
  const lock = await prisma.attendanceLock.findUnique({
    where: { month_year: { month, year } },
  });

  if (!lock) {
    return {
      success: false,
      processedCount: 0,
      errorCount: 1,
      errors: [{ employeeId: '', message: `Attendance not locked for ${year}-${month}` }],
    };
  }

  // 2. Get active employees
  const employees = await prisma.employee.findMany({
    where: { employment_status: 'ACTIVE' },
    include: {
      salary_structures: {
        where: {
          effective_from: { lte: new Date() },
          OR: [
            { effective_to: null },
            { effective_to: { gte: new Date() } },
          ],
        },
        orderBy: { effective_from: 'desc' },
        take: 1,
      },
    },
  });

  // 3. Validate each employee has salary structure
  for (const emp of employees) {
    if (emp.salary_structures.length === 0) {
      errors.push({
        employeeId: emp.id,
        message: `No active salary structure for ${emp.first_name} ${emp.last_name}`,
      });
    } else if (!emp.salary_structures[0].is_compliant) {
      errors.push({
        employeeId: emp.id,
        message: `Salary structure not compliant with 50% rule for ${emp.first_name} ${emp.last_name}`,
      });
    }
  }

  // Update PayrollRun with employee count
  await prisma.payrollRun.update({
    where: { id: payrollRunId },
    data: {
      total_employees: employees.length,
      error_count: errors.length,
      errors: errors.length > 0 ? errors : undefined,
    },
  });

  await job.updateProgress(100);

  if (errors.length > 0) {
    return {
      success: false,
      processedCount: employees.length,
      errorCount: errors.length,
      errors,
    };
  }

  return {
    success: true,
    processedCount: employees.length,
    errorCount: 0,
    nextStage: 'calculation',
  };
}

async function processCalculationStage(
  job: Job<PayrollJobData, PayrollJobResult>
): Promise<PayrollJobResult> {
  const { payrollRunId, month, year } = job.data;
  const errors: Array<{ employeeId: string; message: string }> = [];
  let processedCount = 0;

  // Get PayrollRun for employee list
  const payrollRun = await prisma.payrollRun.findUnique({
    where: { id: payrollRunId },
  });

  if (!payrollRun) {
    throw new Error('PayrollRun not found');
  }

  // Get active employees with salary structures
  const employees = await prisma.employee.findMany({
    where: { employment_status: 'ACTIVE' },
    include: {
      salary_structures: {
        where: {
          effective_from: { lte: new Date() },
          is_compliant: true,
          OR: [
            { effective_to: null },
            { effective_to: { gte: new Date() } },
          ],
        },
        orderBy: { effective_from: 'desc' },
        take: 1,
      },
    },
  });

  const totalEmployees = employees.length;

  for (let i = 0; i < employees.length; i++) {
    const emp = employees[i];

    try {
      const salaryStructure = emp.salary_structures[0];

      // Get attendance summary
      const attendance = await getAttendanceSummary(emp.id, month, year);

      // Calculate payroll
      const result = await calculatePayroll({
        employeeId: emp.id,
        month,
        year,
        salaryStructure: {
          basic_paise: salaryStructure.basic_paise,
          hra_paise: salaryStructure.hra_paise,
          special_allowance_paise: salaryStructure.special_allowance_paise,
          lta_paise: salaryStructure.lta_paise,
          medical_paise: salaryStructure.medical_paise,
          conveyance_paise: salaryStructure.conveyance_paise,
          other_allowances_paise: salaryStructure.other_allowances_paise,
          tax_regime: salaryStructure.tax_regime,
        },
        attendance,
        workState: emp.state,
        gender: emp.gender,
      });

      // Create PayrollRecord
      await prisma.payrollRecord.upsert({
        where: {
          payroll_run_id_employee_id: {
            payroll_run_id: payrollRunId,
            employee_id: emp.id,
          },
        },
        create: {
          payroll_run_id: payrollRunId,
          employee_id: emp.id,
          month,
          year,

          working_days: attendance.workingDays,
          paid_days: attendance.paidDays,
          lop_days: attendance.lopDays,

          basic_paise: salaryStructure.basic_paise,
          hra_paise: salaryStructure.hra_paise,
          special_allowance_paise: salaryStructure.special_allowance_paise,
          lta_paise: salaryStructure.lta_paise,
          medical_paise: salaryStructure.medical_paise,
          conveyance_paise: salaryStructure.conveyance_paise,
          other_allowances_paise: salaryStructure.other_allowances_paise,

          gross_before_lop_paise: result.grossBeforeLOP,
          lop_deduction_paise: result.lopDeduction,
          gross_salary_paise: result.grossSalary,

          pf_employee_paise: result.pfEmployee,
          pf_employer_epf_paise: result.pfEmployerBreakdown.epf,
          pf_employer_eps_paise: result.pfEmployerBreakdown.eps,
          pf_employer_edli_paise: result.pfEmployerBreakdown.edli,
          pf_admin_charges_paise: result.pfEmployerBreakdown.adminCharges,
          pf_total_employer_paise: result.pfEmployerBreakdown.total,
          pf_base_paise: result.pfBase,

          esi_employee_paise: result.esiEmployee,
          esi_employer_paise: result.esiEmployer,
          esi_applicable: result.esiApplicable,

          pt_paise: result.ptAmount,

          tds_paise: result.tdsAmount,
          projected_annual_paise: result.projectedAnnualIncome,
          tax_regime: result.taxRegime,

          total_deductions_paise: result.totalDeductions,
          net_salary_paise: result.netSalary,
          employer_cost_paise: result.employerCost,

          status: 'CALCULATED',
          processed_at: new Date(),
        },
        update: {
          // Same as create for re-runs
          working_days: attendance.workingDays,
          paid_days: attendance.paidDays,
          lop_days: attendance.lopDays,
          gross_salary_paise: result.grossSalary,
          total_deductions_paise: result.totalDeductions,
          net_salary_paise: result.netSalary,
          status: 'CALCULATED',
          processed_at: new Date(),
        },
      });

      processedCount++;
    } catch (error: any) {
      errors.push({
        employeeId: emp.id,
        message: error.message,
      });
    }

    // Update progress
    await job.updateProgress(Math.round(((i + 1) / totalEmployees) * 100));
  }

  // Update PayrollRun
  await prisma.payrollRun.update({
    where: { id: payrollRunId },
    data: {
      processed_count: processedCount,
      success_count: processedCount - errors.length,
      error_count: errors.length,
      errors: errors.length > 0 ? errors : undefined,
    },
  });

  return {
    success: errors.length === 0,
    processedCount,
    errorCount: errors.length,
    errors: errors.length > 0 ? errors : undefined,
    nextStage: errors.length === 0 ? 'statutory' : undefined,
  };
}

async function processStatutoryStage(
  job: Job<PayrollJobData, PayrollJobResult>
): Promise<PayrollJobResult> {
  // TODO: Implement in Plan 06 (ECR, ESI challan generation)
  await job.updateProgress(100);

  return {
    success: true,
    processedCount: 0,
    errorCount: 0,
    nextStage: 'finalization',
  };
}

async function processFinalizationStage(
  job: Job<PayrollJobData, PayrollJobResult>
): Promise<PayrollJobResult> {
  const { payrollRunId } = job.data;

  await prisma.payrollRun.update({
    where: { id: payrollRunId },
    data: {
      status: 'COMPLETED',
      completed_at: new Date(),
    },
  });

  // Update all records to VERIFIED
  await prisma.payrollRecord.updateMany({
    where: {
      payroll_run_id: payrollRunId,
      status: 'CALCULATED',
    },
    data: {
      status: 'VERIFIED',
    },
  });

  await job.updateProgress(100);

  return {
    success: true,
    processedCount: 0,
    errorCount: 0,
  };
}

export { createPayrollWorker };
```
  </action>
  <verify>
    - calculatePayroll produces correct gross, deductions, net
    - Worker processes validation, calculation, statutory, finalization stages
    - PayrollRecord created with all deductions populated
  </verify>
  <done>
    Complete payroll calculation engine implemented with PF/ESI/PT/TDS deductions and multi-stage worker processing
  </done>
</task>

</tasks>

<verification>
1. Unit tests pass for PF, ESI, TDS calculations
2. calculatePayroll correctly aggregates all deductions
3. Worker processes all stages and creates PayrollRecords
4. PF wage ceiling (Rs.15,000) and EPS cap (Rs.1,250) enforced
5. ESI only applied when gross <= Rs.21,000
</verification>

<success_criteria>
- [ ] PF calculation caps at Rs.15,000 basic wage ceiling
- [ ] Employer PF breakdown shows EPF/EPS/EDLI split
- [ ] EPS capped at Rs.1,250 monthly
- [ ] ESI skipped when gross > Rs.21,000
- [ ] TDS uses correct regime slabs
- [ ] LOP deduction calculated correctly
- [ ] Worker creates PayrollRecords with all fields populated
</success_criteria>

<output>
After completion, create `.planning/phases/03-payroll-compliance/03-04-SUMMARY.md`
</output>
