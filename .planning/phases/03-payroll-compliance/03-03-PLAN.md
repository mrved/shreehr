---
phase: 03-payroll-compliance
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/queues/connection.ts
  - src/lib/queues/payroll.queue.ts
  - src/lib/queues/workers/payroll.worker.ts
  - prisma/schema.prisma
  - docker-compose.yml
autonomous: true

user_setup:
  - service: redis
    why: "BullMQ requires Redis for job queue persistence"
    env_vars:
      - name: REDIS_URL
        source: "Local Redis: redis://localhost:6379 or Docker container"

must_haves:
  truths:
    - "BullMQ queue can accept payroll jobs"
    - "Worker can process jobs in background"
    - "Job status can be queried via API"
    - "Failed jobs are retried with exponential backoff"
  artifacts:
    - path: "src/lib/queues/connection.ts"
      provides: "Redis connection for BullMQ"
      exports: ["redis", "getQueueConnection"]
    - path: "src/lib/queues/payroll.queue.ts"
      provides: "Payroll job queue definition"
      exports: ["payrollQueue", "addPayrollJob"]
    - path: "prisma/schema.prisma"
      provides: "PayrollRun and PayrollRecord models"
      contains: "model PayrollRun"
  key_links:
    - from: "src/lib/queues/payroll.queue.ts"
      to: "src/lib/queues/connection.ts"
      via: "Redis connection"
      pattern: "getQueueConnection"
---

<objective>
Set up BullMQ infrastructure for background payroll processing

Purpose: Payroll processing for multiple employees can take minutes. BullMQ provides reliable background job processing with retry logic, progress tracking, and failure handling. This infrastructure is required before the payroll calculation engine.

Output:
- Redis connection configuration
- BullMQ queue for payroll jobs
- PayrollRun and PayrollRecord models for tracking
- Docker compose for local Redis
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payroll-compliance/03-RESEARCH.md
@prisma/schema.prisma
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Redis connection</name>
  <files>
    package.json
    src/lib/queues/connection.ts
    docker-compose.yml
    .env.example
  </files>
  <action>
1. Install BullMQ and ioredis:
   ```bash
   pnpm add bullmq ioredis
   ```

2. Create src/lib/queues/connection.ts:
   ```typescript
   import IORedis from 'ioredis';

   // Redis connection singleton
   let redisConnection: IORedis | null = null;

   /**
    * Get Redis connection for BullMQ
    * Uses REDIS_URL env var, defaults to localhost
    */
   export function getRedisConnection(): IORedis {
     if (!redisConnection) {
       const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';

       redisConnection = new IORedis(redisUrl, {
         maxRetriesPerRequest: null, // Required for BullMQ
         enableReadyCheck: false,
       });

       redisConnection.on('error', (err) => {
         console.error('Redis connection error:', err);
       });

       redisConnection.on('connect', () => {
         console.log('Connected to Redis');
       });
     }

     return redisConnection;
   }

   /**
    * Get connection options for BullMQ Queue/Worker
    */
   export function getQueueConnection() {
     return {
       connection: getRedisConnection(),
     };
   }

   /**
    * Close Redis connection (for graceful shutdown)
    */
   export async function closeRedisConnection(): Promise<void> {
     if (redisConnection) {
       await redisConnection.quit();
       redisConnection = null;
     }
   }
   ```

3. Create/update docker-compose.yml:
   ```yaml
   version: '3.8'

   services:
     postgres:
       image: postgres:16-alpine
       container_name: shreehr-postgres
       environment:
         POSTGRES_USER: shreehr
         POSTGRES_PASSWORD: shreehr_local
         POSTGRES_DB: shreehr
       ports:
         - "5432:5432"
       volumes:
         - postgres_data:/var/lib/postgresql/data

     redis:
       image: redis:7-alpine
       container_name: shreehr-redis
       ports:
         - "6379:6379"
       volumes:
         - redis_data:/data
       command: redis-server --appendonly yes

   volumes:
     postgres_data:
     redis_data:
   ```

4. Update .env.example:
   ```
   # Database
   DATABASE_URL="postgresql://shreehr:shreehr_local@localhost:5432/shreehr?schema=public"

   # Redis (for BullMQ job queue)
   REDIS_URL="redis://localhost:6379"

   # Encryption
   ENCRYPTION_KEY="your-32-byte-hex-key"

   # NextAuth
   NEXTAUTH_SECRET="your-secret-key"
   NEXTAUTH_URL="http://localhost:3000"
   ```
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - bullmq and ioredis in package.json dependencies
    - `docker compose up -d redis` starts Redis container
  </verify>
  <done>
    Redis connection utility created, Docker Compose includes Redis service
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PayrollRun and PayrollRecord models</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
Add PayrollRun and PayrollRecord models to schema.prisma:

```prisma
// ============================================================================
// PAYROLL PROCESSING
// ============================================================================

model PayrollRun {
  id    String @id @default(cuid())
  month Int    // 1-12
  year  Int

  // Processing status
  status         PayrollRunStatus @default(PENDING)
  current_stage  PayrollStage     @default(VALIDATION)

  // Progress tracking
  total_employees    Int @default(0)
  processed_count    Int @default(0)
  success_count      Int @default(0)
  error_count        Int @default(0)

  // Timing
  started_at   DateTime?
  completed_at DateTime?

  // BullMQ job tracking
  job_id String?

  // Error details
  errors Json? // Array of { employee_id, error_message }

  // Audit fields
  created_at DateTime @default(now())
  created_by String?
  creator    User?    @relation("PayrollRunCreatedBy", fields: [created_by], references: [id])
  updated_at DateTime @updatedAt

  // Relations
  records PayrollRecord[]

  @@unique([month, year])
  @@map("payroll_runs")
}

enum PayrollRunStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REVERTED
}

enum PayrollStage {
  VALIDATION      // Check attendance lock, salary structures
  CALCULATION     // Calculate gross, deductions for each employee
  STATUTORY       // Generate statutory files (ECR, ESI, TDS)
  FINALIZATION    // Mark as complete, send notifications
}

model PayrollRecord {
  id String @id @default(cuid())

  // Links
  payroll_run_id String
  payroll_run    PayrollRun @relation(fields: [payroll_run_id], references: [id], onDelete: Cascade)
  employee_id    String
  employee       Employee   @relation(fields: [employee_id], references: [id])

  // Period
  month Int
  year  Int

  // Attendance data (from locked attendance)
  working_days Int @default(0)
  paid_days    Int @default(0)
  lop_days     Int @default(0)

  // Earnings (in paise)
  basic_paise             Int @default(0)
  hra_paise               Int @default(0)
  special_allowance_paise Int @default(0)
  lta_paise               Int @default(0)
  medical_paise           Int @default(0)
  conveyance_paise        Int @default(0)
  other_allowances_paise  Int @default(0)

  // Gross (before LOP)
  gross_before_lop_paise Int @default(0)

  // LOP deduction
  lop_deduction_paise Int @default(0)

  // Gross (after LOP)
  gross_salary_paise Int @default(0)

  // Statutory deductions (in paise)
  // PF - Employee
  pf_employee_paise Int @default(0)

  // PF - Employer breakdown
  pf_employer_epf_paise  Int @default(0) // 3.67%
  pf_employer_eps_paise  Int @default(0) // 8.33% capped at Rs.1,250
  pf_employer_edli_paise Int @default(0) // 0.50%
  pf_admin_charges_paise Int @default(0) // ~0.51%
  pf_total_employer_paise Int @default(0)

  // PF base (for ECR)
  pf_base_paise Int @default(0) // min(basic, 15000)

  // ESI
  esi_employee_paise Int @default(0) // 0.75%
  esi_employer_paise Int @default(0) // 3.25%
  esi_applicable     Boolean @default(false)

  // PT
  pt_paise Int @default(0)

  // TDS
  tds_paise             Int @default(0)
  projected_annual_paise Int @default(0) // For TDS calculation
  tax_regime            String @default("NEW")

  // Other deductions
  other_deductions_paise Int @default(0)

  // Totals
  total_deductions_paise Int @default(0)
  net_salary_paise       Int @default(0)

  // Employer cost
  employer_cost_paise Int @default(0) // gross + employer PF + employer ESI

  // Status
  status       PayrollRecordStatus @default(DRAFT)
  processed_at DateTime?
  error        String?

  // Audit fields
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@unique([payroll_run_id, employee_id])
  @@index([employee_id, month, year])
  @@map("payroll_records")
}

enum PayrollRecordStatus {
  DRAFT
  CALCULATED
  VERIFIED
  PAID
  ERROR
}
```

Add relations to existing models:

1. Add to User model:
   ```prisma
   created_payroll_runs PayrollRun[] @relation("PayrollRunCreatedBy")
   ```

2. Add to Employee model:
   ```prisma
   payroll_records PayrollRecord[]
   ```

Run `pnpm db:push` to update database schema.
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - `pnpm db:push` succeeds
    - PayrollRun and PayrollRecord tables created in database
  </verify>
  <done>
    PayrollRun and PayrollRecord models created with all earnings, deductions, and employer cost fields
  </done>
</task>

<task type="auto">
  <name>Task 3: Create BullMQ payroll queue and worker stub</name>
  <files>
    src/lib/queues/payroll.queue.ts
    src/lib/queues/workers/payroll.worker.ts
  </files>
  <action>
1. Create src/lib/queues/payroll.queue.ts:
   ```typescript
   import { Queue, Job } from 'bullmq';
   import { getQueueConnection } from './connection';

   export interface PayrollJobData {
     payrollRunId: string;
     month: number;
     year: number;
     stage: 'validation' | 'calculation' | 'statutory' | 'finalization';
     employeeIds?: string[]; // For partial processing
   }

   export interface PayrollJobResult {
     success: boolean;
     processedCount: number;
     errorCount: number;
     errors?: Array<{ employeeId: string; message: string }>;
     nextStage?: PayrollJobData['stage'];
   }

   // Queue instance
   let payrollQueueInstance: Queue<PayrollJobData, PayrollJobResult> | null = null;

   /**
    * Get or create the payroll queue
    */
   export function getPayrollQueue(): Queue<PayrollJobData, PayrollJobResult> {
     if (!payrollQueueInstance) {
       payrollQueueInstance = new Queue<PayrollJobData, PayrollJobResult>('payroll', {
         ...getQueueConnection(),
         defaultJobOptions: {
           attempts: 3,
           backoff: {
             type: 'exponential',
             delay: 2000, // Start with 2 seconds
           },
           removeOnComplete: {
             age: 24 * 3600, // Keep completed jobs for 24 hours
             count: 100, // Keep last 100 completed jobs
           },
           removeOnFail: {
             age: 7 * 24 * 3600, // Keep failed jobs for 7 days
           },
         },
       });
     }

     return payrollQueueInstance;
   }

   /**
    * Add a payroll job to the queue
    */
   export async function addPayrollJob(
     data: PayrollJobData,
     options?: {
       priority?: number;
       delay?: number;
     }
   ): Promise<Job<PayrollJobData, PayrollJobResult>> {
     const queue = getPayrollQueue();

     const jobId = `payroll-${data.payrollRunId}-${data.stage}`;

     return queue.add(data.stage, data, {
       jobId,
       priority: options?.priority ?? 1,
       delay: options?.delay,
     });
   }

   /**
    * Get job status
    */
   export async function getPayrollJobStatus(
     payrollRunId: string,
     stage: string
   ): Promise<{
     state: string;
     progress: number;
     result?: PayrollJobResult;
     failedReason?: string;
   } | null> {
     const queue = getPayrollQueue();
     const jobId = `payroll-${payrollRunId}-${stage}`;

     const job = await queue.getJob(jobId);
     if (!job) return null;

     const state = await job.getState();
     const progress = job.progress as number || 0;

     return {
       state,
       progress,
       result: job.returnvalue,
       failedReason: job.failedReason,
     };
   }

   /**
    * Cancel pending payroll jobs
    */
   export async function cancelPayrollJobs(payrollRunId: string): Promise<void> {
     const queue = getPayrollQueue();
     const stages = ['validation', 'calculation', 'statutory', 'finalization'];

     for (const stage of stages) {
       const jobId = `payroll-${payrollRunId}-${stage}`;
       const job = await queue.getJob(jobId);

       if (job) {
         const state = await job.getState();
         if (state === 'waiting' || state === 'delayed') {
           await job.remove();
         }
       }
     }
   }
   ```

2. Create src/lib/queues/workers/payroll.worker.ts (stub for now, full implementation in Plan 04):
   ```typescript
   import { Worker, Job } from 'bullmq';
   import { getQueueConnection } from '../connection';
   import { PayrollJobData, PayrollJobResult } from '../payroll.queue';
   import { prisma } from '@/lib/db';

   /**
    * Create and start the payroll worker
    * This processes payroll jobs from the queue
    */
   export function createPayrollWorker(): Worker<PayrollJobData, PayrollJobResult> {
     const worker = new Worker<PayrollJobData, PayrollJobResult>(
       'payroll',
       async (job: Job<PayrollJobData, PayrollJobResult>) => {
         console.log(`Processing payroll job: ${job.id}, stage: ${job.data.stage}`);

         const { payrollRunId, stage } = job.data;

         // Update PayrollRun to show processing
         await prisma.payrollRun.update({
           where: { id: payrollRunId },
           data: {
             status: 'PROCESSING',
             current_stage: stage.toUpperCase() as any,
             started_at: new Date(),
           },
         });

         try {
           let result: PayrollJobResult;

           switch (stage) {
             case 'validation':
               result = await processValidationStage(job);
               break;
             case 'calculation':
               result = await processCalculationStage(job);
               break;
             case 'statutory':
               result = await processStatutoryStage(job);
               break;
             case 'finalization':
               result = await processFinalizationStage(job);
               break;
             default:
               throw new Error(`Unknown stage: ${stage}`);
           }

           return result;
         } catch (error: any) {
           // Update PayrollRun with error
           await prisma.payrollRun.update({
             where: { id: payrollRunId },
             data: {
               status: 'FAILED',
               errors: [{ stage, message: error.message }],
             },
           });

           throw error;
         }
       },
       {
         ...getQueueConnection(),
         concurrency: 1, // Process one payroll at a time
       }
     );

     worker.on('completed', (job, result) => {
       console.log(`Payroll job ${job.id} completed:`, result);
     });

     worker.on('failed', (job, error) => {
       console.error(`Payroll job ${job?.id} failed:`, error.message);
     });

     return worker;
   }

   // Stage processors - stubs for now
   async function processValidationStage(
     job: Job<PayrollJobData, PayrollJobResult>
   ): Promise<PayrollJobResult> {
     // TODO: Implement in Plan 04
     // 1. Check attendance lock exists
     // 2. Validate all employees have salary structures
     // 3. Validate salary structures are compliant

     await job.updateProgress(100);

     return {
       success: true,
       processedCount: 0,
       errorCount: 0,
       nextStage: 'calculation',
     };
   }

   async function processCalculationStage(
     job: Job<PayrollJobData, PayrollJobResult>
   ): Promise<PayrollJobResult> {
     // TODO: Implement in Plan 04
     // 1. Get all active employees
     // 2. For each employee, calculate:
     //    - Gross salary from salary structure
     //    - LOP deduction from attendance
     //    - PF contribution
     //    - ESI contribution
     //    - PT deduction
     //    - TDS deduction
     //    - Net salary

     await job.updateProgress(100);

     return {
       success: true,
       processedCount: 0,
       errorCount: 0,
       nextStage: 'statutory',
     };
   }

   async function processStatutoryStage(
     job: Job<PayrollJobData, PayrollJobResult>
   ): Promise<PayrollJobResult> {
     // TODO: Implement in Plan 06
     // 1. Generate ECR file
     // 2. Generate ESI challan
     // 3. Calculate TDS totals

     await job.updateProgress(100);

     return {
       success: true,
       processedCount: 0,
       errorCount: 0,
       nextStage: 'finalization',
     };
   }

   async function processFinalizationStage(
     job: Job<PayrollJobData, PayrollJobResult>
   ): Promise<PayrollJobResult> {
     const { payrollRunId } = job.data;

     // Mark PayrollRun as complete
     await prisma.payrollRun.update({
       where: { id: payrollRunId },
       data: {
         status: 'COMPLETED',
         completed_at: new Date(),
       },
     });

     await job.updateProgress(100);

     return {
       success: true,
       processedCount: 0,
       errorCount: 0,
     };
   }

   // Export for standalone worker process
   export { createPayrollWorker };
   ```
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - Queue can be created without errors
    - Worker stub processes jobs
  </verify>
  <done>
    BullMQ payroll queue and worker infrastructure created with stage-based processing pattern
  </done>
</task>

</tasks>

<verification>
1. Dependencies: bullmq and ioredis installed
2. Redis: Docker compose starts Redis container
3. Queue: payrollQueue can be created and jobs added
4. Models: PayrollRun and PayrollRecord tables exist
</verification>

<success_criteria>
- [ ] bullmq and ioredis in package.json
- [ ] Redis connection works (with Docker or external)
- [ ] PayrollRun model tracks job status and stage
- [ ] PayrollRecord model stores all earnings and deductions
- [ ] Queue accepts jobs with retry configuration
</success_criteria>

<output>
After completion, create `.planning/phases/03-payroll-compliance/03-03-SUMMARY.md`
</output>
