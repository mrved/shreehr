---
phase: 06-ai-assistant
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ai/tools/employee-data.ts
  - src/lib/ai/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "Employee can retrieve their own leave balance via AI"
    - "Employee can retrieve their own attendance summary via AI"
    - "Employee can retrieve their own salary information via AI"
    - "Manager can retrieve subordinate data via AI"
    - "Employee cannot access another employee's data via AI"
  artifacts:
    - path: "src/lib/ai/tools/employee-data.ts"
      provides: "RBAC-enforced employee data retrieval functions"
      exports: ["getEmployeeLeaveBalance", "getEmployeeAttendance", "getEmployeeSalary", "getEmployeeLoans"]
    - path: "src/lib/ai/tools/index.ts"
      provides: "AI SDK tool definitions"
      exports: ["employeeDataTools"]
  key_links:
    - from: "src/lib/ai/tools/employee-data.ts"
      to: "prisma"
      via: "database queries"
      pattern: "prisma\\.(leaveBalance|attendance|payrollRecord|employeeLoan)"
    - from: "src/lib/ai/tools/employee-data.ts"
      to: "session"
      via: "RBAC check"
      pattern: "session\\.user\\.(id|role)"
---

<objective>
Create AI tool functions for retrieving employee-specific data (leave balance, attendance, salary, loans) with proper RBAC enforcement.

Purpose: Enable the AI assistant to answer factual HR queries by retrieving real data from the database while respecting role-based access control.
Output: Secure data retrieval functions that the AI can call to answer questions like "What's my leave balance?" or "Show my team's attendance."
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-assistant/06-RESEARCH.md

@prisma/schema.prisma
@src/lib/auth.ts
@src/lib/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create employee data retrieval functions with RBAC</name>
  <files>
    src/lib/ai/tools/employee-data.ts
  </files>
  <action>
Create `src/lib/ai/tools/employee-data.ts` with RBAC-enforced data retrieval functions.

**CRITICAL:** RBAC must be enforced in the function body, NOT in prompts. The AI cannot be trusted to follow prompt instructions for security.

1. Create types for function context:
```typescript
interface ToolContext {
  userId: string;
  employeeId: string | null;
  role: string;
}
```

2. Create RBAC helper function:
```typescript
async function validateAccess(
  context: ToolContext,
  targetEmployeeId: string | undefined
): Promise<{ allowed: boolean; employeeId: string; error?: string }> {
  // If no target specified, use caller's employee
  const requestedId = targetEmployeeId || context.employeeId;

  if (!requestedId) {
    return { allowed: false, employeeId: '', error: 'No employee profile linked to your account' };
  }

  // Employees can only see their own data
  if (context.role === 'EMPLOYEE') {
    if (requestedId !== context.employeeId) {
      return { allowed: false, employeeId: '', error: 'You can only view your own data' };
    }
    return { allowed: true, employeeId: requestedId };
  }

  // Managers can see their subordinates
  if (context.role === 'HR_MANAGER' || context.role === 'MANAGER') {
    // Check if target is a subordinate
    const subordinate = await prisma.employee.findFirst({
      where: {
        id: requestedId,
        reporting_manager_id: context.employeeId,
      },
    });

    if (subordinate || requestedId === context.employeeId) {
      return { allowed: true, employeeId: requestedId };
    }
    return { allowed: false, employeeId: '', error: 'You can only view your own or subordinates data' };
  }

  // Admins can see everyone
  if (['ADMIN', 'SUPER_ADMIN', 'PAYROLL_MANAGER'].includes(context.role)) {
    return { allowed: true, employeeId: requestedId };
  }

  return { allowed: false, employeeId: '', error: 'Access denied' };
}
```

3. Create data retrieval functions:

**getEmployeeLeaveBalance:**
```typescript
export async function getEmployeeLeaveBalance(
  context: ToolContext,
  targetEmployeeId?: string,
  year?: number
) {
  const access = await validateAccess(context, targetEmployeeId);
  if (!access.allowed) return { error: access.error };

  const currentYear = year || new Date().getFullYear();

  const balances = await prisma.leaveBalance.findMany({
    where: {
      employee_id: access.employeeId,
      year: currentYear,
    },
    select: {
      leave_type: true,
      opening: true,
      accrued: true,
      used: true,
      balance: true,
    },
  });

  // Also get pending requests
  const pendingRequests = await prisma.leaveRequest.findMany({
    where: {
      employee_id: access.employeeId,
      status: 'PENDING',
    },
    select: {
      leave_type: { select: { name: true } },
      start_date: true,
      end_date: true,
      days_count: true,
    },
  });

  return {
    year: currentYear,
    balances: balances.map(b => ({
      type: b.leave_type,
      available: b.balance,
      used: b.used,
      accrued: b.accrued,
    })),
    pendingRequests: pendingRequests.map(r => ({
      type: r.leave_type.name,
      days: r.days_count,
      from: r.start_date.toISOString().split('T')[0],
      to: r.end_date.toISOString().split('T')[0],
    })),
  };
}
```

**getEmployeeAttendance:**
```typescript
export async function getEmployeeAttendance(
  context: ToolContext,
  targetEmployeeId?: string,
  month?: number,
  year?: number
) {
  const access = await validateAccess(context, targetEmployeeId);
  if (!access.allowed) return { error: access.error };

  const now = new Date();
  const targetMonth = month || now.getMonth() + 1;
  const targetYear = year || now.getFullYear();

  // Get attendance records for the month
  const startDate = new Date(targetYear, targetMonth - 1, 1);
  const endDate = new Date(targetYear, targetMonth, 0);

  const records = await prisma.attendance.findMany({
    where: {
      employee_id: access.employeeId,
      date: {
        gte: startDate,
        lte: endDate,
      },
    },
    select: {
      date: true,
      status: true,
      work_minutes: true,
      check_in: true,
      check_out: true,
    },
    orderBy: { date: 'asc' },
  });

  // Calculate summary
  const summary = {
    present: records.filter(r => r.status === 'PRESENT').length,
    absent: records.filter(r => r.status === 'ABSENT').length,
    halfDay: records.filter(r => r.status === 'HALF_DAY').length,
    onLeave: records.filter(r => r.status === 'ON_LEAVE').length,
    totalWorkHours: Math.round(records.reduce((sum, r) => sum + r.work_minutes, 0) / 60),
  };

  return {
    month: targetMonth,
    year: targetYear,
    summary,
    // Only include last 5 days detail to avoid token explosion
    recentDays: records.slice(-5).map(r => ({
      date: r.date.toISOString().split('T')[0],
      status: r.status,
      checkIn: r.check_in?.toISOString().split('T')[1]?.substring(0, 5),
      checkOut: r.check_out?.toISOString().split('T')[1]?.substring(0, 5),
    })),
  };
}
```

**getEmployeeSalary:**
```typescript
export async function getEmployeeSalary(
  context: ToolContext,
  targetEmployeeId?: string,
  month?: number,
  year?: number
) {
  const access = await validateAccess(context, targetEmployeeId);
  if (!access.allowed) return { error: access.error };

  const now = new Date();
  const targetMonth = month || now.getMonth(); // Previous month by default
  const targetYear = year || (targetMonth === 0 ? now.getFullYear() - 1 : now.getFullYear());
  const actualMonth = targetMonth === 0 ? 12 : targetMonth;

  const record = await prisma.payrollRecord.findFirst({
    where: {
      employee_id: access.employeeId,
      month: actualMonth,
      year: targetYear,
      status: { in: ['CALCULATED', 'VERIFIED', 'PAID'] },
    },
    select: {
      month: true,
      year: true,
      gross_salary_paise: true,
      net_salary_paise: true,
      basic_paise: true,
      hra_paise: true,
      pf_employee_paise: true,
      pt_paise: true,
      tds_paise: true,
      lop_days: true,
      lop_deduction_paise: true,
      reimbursements_paise: true,
      loan_deductions_paise: true,
      status: true,
    },
  });

  if (!record) {
    return { error: `No salary record found for ${actualMonth}/${targetYear}` };
  }

  // Convert paise to rupees for readability
  const toRupees = (paise: number) => (paise / 100).toFixed(2);

  return {
    month: record.month,
    year: record.year,
    status: record.status,
    earnings: {
      basic: toRupees(record.basic_paise),
      hra: toRupees(record.hra_paise),
      gross: toRupees(record.gross_salary_paise),
      reimbursements: toRupees(record.reimbursements_paise),
    },
    deductions: {
      pf: toRupees(record.pf_employee_paise),
      pt: toRupees(record.pt_paise),
      tds: toRupees(record.tds_paise),
      lop: toRupees(record.lop_deduction_paise),
      loans: toRupees(record.loan_deductions_paise),
    },
    netSalary: toRupees(record.net_salary_paise),
    lopDays: record.lop_days,
  };
}
```

**getEmployeeLoans:**
```typescript
export async function getEmployeeLoans(
  context: ToolContext,
  targetEmployeeId?: string
) {
  const access = await validateAccess(context, targetEmployeeId);
  if (!access.allowed) return { error: access.error };

  const loans = await prisma.employeeLoan.findMany({
    where: {
      employee_id: access.employeeId,
      status: { in: ['ACTIVE', 'PENDING'] },
    },
    select: {
      id: true,
      loan_type: true,
      principal_paise: true,
      remaining_balance_paise: true,
      emi_paise: true,
      tenure_months: true,
      start_date: true,
      end_date: true,
      status: true,
      deductions: {
        where: { status: 'SCHEDULED' },
        select: { month: true, year: true },
        take: 3,
        orderBy: [{ year: 'asc' }, { month: 'asc' }],
      },
    },
  });

  const toRupees = (paise: number) => (paise / 100).toFixed(2);

  return {
    activeLoans: loans.map(l => ({
      type: l.loan_type,
      principal: toRupees(l.principal_paise),
      remaining: toRupees(l.remaining_balance_paise),
      emi: toRupees(l.emi_paise),
      status: l.status,
      nextDeductions: l.deductions.map(d => `${d.month}/${d.year}`),
    })),
    totalOutstanding: toRupees(loans.reduce((sum, l) => sum + l.remaining_balance_paise, 0)),
  };
}
```

**getTeamSummary (for managers):**
```typescript
export async function getTeamSummary(
  context: ToolContext
) {
  // Only managers and above can see team data
  if (!['HR_MANAGER', 'ADMIN', 'SUPER_ADMIN', 'PAYROLL_MANAGER'].includes(context.role)) {
    // For regular managers, check if they have subordinates
    const hasSubordinates = await prisma.employee.count({
      where: { reporting_manager_id: context.employeeId },
    });

    if (hasSubordinates === 0) {
      return { error: 'You do not have any team members' };
    }
  }

  const today = new Date();

  // Get subordinates
  const subordinates = await prisma.employee.findMany({
    where: context.role === 'EMPLOYEE'
      ? { reporting_manager_id: context.employeeId }
      : {}, // Admins see all
    select: {
      id: true,
      first_name: true,
      last_name: true,
      attendances: {
        where: { date: today },
        select: { status: true },
      },
      leave_requests: {
        where: { status: 'PENDING' },
        select: { id: true },
      },
    },
  });

  return {
    teamSize: subordinates.length,
    todayAttendance: {
      present: subordinates.filter(s => s.attendances[0]?.status === 'PRESENT').length,
      absent: subordinates.filter(s => s.attendances[0]?.status === 'ABSENT').length,
      onLeave: subordinates.filter(s => s.attendances[0]?.status === 'ON_LEAVE').length,
      notMarked: subordinates.filter(s => !s.attendances[0]).length,
    },
    pendingLeaveRequests: subordinates.reduce((sum, s) => sum + s.leave_requests.length, 0),
  };
}
```
  </action>
  <verify>
    - `src/lib/ai/tools/employee-data.ts` exists
    - TypeScript compiles: `pnpm tsc --noEmit`
    - All functions export correctly
    - RBAC validation is in function body, not comments
  </verify>
  <done>
    - Leave balance retrieval with RBAC
    - Attendance summary retrieval with RBAC
    - Salary information retrieval with RBAC
    - Loan information retrieval with RBAC
    - Team summary for managers
    - All amounts converted from paise to rupees for readability
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI SDK tool definitions</name>
  <files>
    src/lib/ai/tools/index.ts
  </files>
  <action>
Create `src/lib/ai/tools/index.ts` to define AI SDK tools using the data retrieval functions.

```typescript
import { tool } from 'ai';
import { z } from 'zod';
import {
  getEmployeeLeaveBalance,
  getEmployeeAttendance,
  getEmployeeSalary,
  getEmployeeLoans,
  getTeamSummary,
} from './employee-data';

// Tool context type (passed from chat route)
export interface ToolContext {
  userId: string;
  employeeId: string | null;
  role: string;
}

// Factory function to create tools with context
export function createEmployeeDataTools(context: ToolContext) {
  return {
    getLeaveBalance: tool({
      description: 'Get leave balance for current user or specified employee (managers only). Shows available leave days by type and any pending requests.',
      parameters: z.object({
        employeeId: z.string().optional().describe('Employee ID (managers only, omit for own data)'),
        year: z.number().optional().describe('Year for balance (defaults to current year)'),
      }),
      execute: async ({ employeeId, year }) => {
        return getEmployeeLeaveBalance(context, employeeId, year);
      },
    }),

    getAttendance: tool({
      description: 'Get attendance summary for current user or specified employee. Shows present/absent days and recent check-in/out times.',
      parameters: z.object({
        employeeId: z.string().optional().describe('Employee ID (managers only, omit for own data)'),
        month: z.number().min(1).max(12).optional().describe('Month (1-12, defaults to current)'),
        year: z.number().optional().describe('Year (defaults to current)'),
      }),
      execute: async ({ employeeId, month, year }) => {
        return getEmployeeAttendance(context, employeeId, month, year);
      },
    }),

    getSalary: tool({
      description: 'Get salary details for current user or specified employee. Shows earnings, deductions, and net salary.',
      parameters: z.object({
        employeeId: z.string().optional().describe('Employee ID (managers only, omit for own data)'),
        month: z.number().min(1).max(12).optional().describe('Month (1-12, defaults to previous month)'),
        year: z.number().optional().describe('Year (defaults to current)'),
      }),
      execute: async ({ employeeId, month, year }) => {
        return getEmployeeSalary(context, employeeId, month, year);
      },
    }),

    getLoans: tool({
      description: 'Get active loan information for current user or specified employee. Shows outstanding balance and upcoming EMI deductions.',
      parameters: z.object({
        employeeId: z.string().optional().describe('Employee ID (managers only, omit for own data)'),
      }),
      execute: async ({ employeeId }) => {
        return getEmployeeLoans(context, employeeId);
      },
    }),

    getTeamSummary: tool({
      description: 'Get team summary including attendance and pending approvals. Only available for managers.',
      parameters: z.object({}),
      execute: async () => {
        return getTeamSummary(context);
      },
    }),
  };
}

// Export type for use in chat route
export type EmployeeDataTools = ReturnType<typeof createEmployeeDataTools>;
```

Add helper to get context from session:
```typescript
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';

export async function getToolContext(): Promise<ToolContext | null> {
  const session = await auth();
  if (!session?.user?.id) return null;

  // Get employee ID for the user
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { employee_id: true, role: true },
  });

  if (!user) return null;

  return {
    userId: session.user.id,
    employeeId: user.employee_id,
    role: user.role,
  };
}
```
  </action>
  <verify>
    - `src/lib/ai/tools/index.ts` exists
    - Exports `createEmployeeDataTools`, `getToolContext`, `ToolContext`
    - TypeScript compiles: `pnpm tsc --noEmit`
    - Tool descriptions are clear and actionable
  </verify>
  <done>
    - AI SDK tool definitions for all employee data queries
    - Factory function creates tools with injected context (secure)
    - Helper function extracts context from session
    - Tool descriptions guide LLM on when to use each tool
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `pnpm tsc --noEmit`
2. All tool functions export correctly
3. RBAC checks are in function bodies (grep for validateAccess calls)
4. Tool descriptions are clear for LLM understanding
</verification>

<success_criteria>
- Employee data retrieval functions created with RBAC enforcement
- AI SDK tool definitions created for leave, attendance, salary, loans
- Team summary tool for managers
- Context injection pattern (not passing session directly)
- All amounts converted from paise to rupees for LLM readability
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-assistant/06-02-SUMMARY.md`
</output>
