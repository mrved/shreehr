---
phase: 06-ai-assistant
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - src/lib/ai/prompts.ts
  - src/lib/ai/conversation.ts
  - src/app/api/chat/route.ts
  - src/app/api/conversations/route.ts
  - src/app/api/conversations/[id]/route.ts
  - src/app/api/policies/route.ts
  - src/app/api/policies/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Employee can send a message and receive streaming response"
    - "AI can call employee data tools to answer HR queries"
    - "AI can call policy search tool to answer policy questions"
    - "Conversation history is persisted in database"
    - "Admin can create and manage policy documents"
  artifacts:
    - path: "src/app/api/chat/route.ts"
      provides: "Chat API with streaming and tool calling"
      exports: ["POST"]
    - path: "src/lib/ai/conversation.ts"
      provides: "Conversation management functions"
      exports: ["getOrCreateConversation", "saveMessage", "getConversationHistory"]
    - path: "src/app/api/policies/route.ts"
      provides: "Policy document CRUD"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/chat/route.ts"
      to: "src/lib/ai/tools"
      via: "tool calling"
      pattern: "createEmployeeDataTools|createPolicySearchTool"
    - from: "src/app/api/chat/route.ts"
      to: "streamText"
      via: "AI SDK streaming"
      pattern: "streamText\\("
---

<objective>
Create the chat API route with streaming responses, tool calling for data and policy queries, conversation history management, and policy document management APIs.

Purpose: Provide the core AI chat functionality that integrates employee data tools and RAG-powered policy search with conversation persistence.
Output: Working chat API that employees can use to ask HR questions and get accurate, role-aware responses.
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-assistant/06-RESEARCH.md

@src/lib/ai/ollama-client.ts
@src/lib/ai/tools/index.ts
@src/lib/ai/tools/policy-search.ts
@src/lib/auth.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create system prompt and conversation management</name>
  <files>
    src/lib/ai/prompts.ts
    src/lib/ai/conversation.ts
  </files>
  <action>
1. Create `src/lib/ai/prompts.ts` with the system prompt:

```typescript
/**
 * System prompt for HR Assistant.
 * Designed for grounding (preventing hallucination) and tool usage.
 */
export const HR_ASSISTANT_SYSTEM_PROMPT = `You are an HR Assistant for ShreeHR, a company HRMS system. You help employees with HR-related questions.

## Your Capabilities

You have access to tools to retrieve real employee data and search company policies:

1. **Employee Data Tools** (use for factual questions about the employee):
   - getLeaveBalance: Check leave balances and pending requests
   - getAttendance: View attendance summary and recent records
   - getSalary: View salary details and deductions
   - getLoans: Check active loans and EMI details
   - getTeamSummary: For managers - view team attendance and pending approvals

2. **Policy Search** (use for policy/procedure questions):
   - searchPolicies: Search company policy documents for answers

## Guidelines

1. **Use Tools for Facts**: For questions about specific data (leave balance, salary, attendance), ALWAYS use the appropriate tool. Never guess or make up numbers.

2. **Cite Sources**: When answering policy questions, cite the source document. Example: "According to the Leave Policy..."

3. **No Information**: If searchPolicies returns no results, say "I couldn't find information about that in our policies. Please contact HR admin." Do NOT make up policies.

4. **Role Awareness**: You can only access data the employee is authorized to see. Employees see their own data; managers can see their team's data.

5. **Be Concise**: Keep responses focused and actionable. Use bullet points for lists.

6. **Escalation**: If you can't help after 2-3 attempts, suggest contacting HR admin directly.

## Conversation Style

- Professional but friendly
- Use Indian English spelling conventions (organisation, favour, etc.)
- Currency in INR (Rs. or â‚¹)
- Dates in DD/MM/YYYY format

## Current Context

Company: ShreeHR (20-person Indian company)
System: Self-hosted HRMS with payroll, attendance, leave management`;

/**
 * Create a greeting message for new conversations.
 */
export function getGreetingMessage(employeeName: string): string {
  return `Hello ${employeeName}! I'm your HR Assistant. I can help you with:

- Leave balance and applications
- Attendance records
- Salary and payslip queries
- Company policies and procedures
- Loan information

What would you like to know?`;
}
```

2. Create `src/lib/ai/conversation.ts` for conversation management:

```typescript
import { prisma } from '@/lib/db';

const MAX_HISTORY_MESSAGES = 20; // Keep last 20 messages for context

export interface ConversationMessage {
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  toolCalls?: unknown;
}

/**
 * Get or create a conversation for a user.
 * If conversationId is provided, returns that conversation (with auth check).
 * Otherwise, creates a new conversation.
 */
export async function getOrCreateConversation(
  userId: string,
  conversationId?: string
): Promise<{ id: string; isNew: boolean }> {
  if (conversationId) {
    // Verify ownership
    const existing = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        user_id: userId,
      },
    });

    if (existing) {
      return { id: existing.id, isNew: false };
    }
    // If not found or not owned, fall through to create new
  }

  // Create new conversation
  const conversation = await prisma.conversation.create({
    data: {
      user_id: userId,
    },
  });

  return { id: conversation.id, isNew: true };
}

/**
 * Get conversation history for AI context.
 * Returns last N messages to fit within context window.
 */
export async function getConversationHistory(
  conversationId: string
): Promise<ConversationMessage[]> {
  const messages = await prisma.message.findMany({
    where: { conversation_id: conversationId },
    orderBy: { created_at: 'asc' },
    take: MAX_HISTORY_MESSAGES,
    select: {
      role: true,
      content: true,
      tool_calls: true,
    },
  });

  return messages.map((m) => ({
    role: m.role as ConversationMessage['role'],
    content: m.content,
    toolCalls: m.tool_calls,
  }));
}

/**
 * Save a message to conversation history.
 */
export async function saveMessage(
  conversationId: string,
  role: string,
  content: string,
  toolCalls?: unknown
): Promise<void> {
  await prisma.message.create({
    data: {
      conversation_id: conversationId,
      role,
      content,
      tool_calls: toolCalls ? JSON.parse(JSON.stringify(toolCalls)) : undefined,
    },
  });

  // Update conversation title from first user message
  if (role === 'user') {
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      select: { title: true },
    });

    if (!conversation?.title) {
      // Use first 50 chars of first user message as title
      const title = content.length > 50 ? content.substring(0, 47) + '...' : content;
      await prisma.conversation.update({
        where: { id: conversationId },
        data: { title },
      });
    }
  }
}

/**
 * List conversations for a user.
 */
export async function listConversations(
  userId: string,
  limit: number = 20
) {
  return prisma.conversation.findMany({
    where: { user_id: userId },
    orderBy: { updated_at: 'desc' },
    take: limit,
    select: {
      id: true,
      title: true,
      created_at: true,
      updated_at: true,
    },
  });
}

/**
 * Delete a conversation and its messages.
 */
export async function deleteConversation(
  userId: string,
  conversationId: string
): Promise<boolean> {
  const deleted = await prisma.conversation.deleteMany({
    where: {
      id: conversationId,
      user_id: userId,
    },
  });

  return deleted.count > 0;
}
```
  </action>
  <verify>
    - `src/lib/ai/prompts.ts` exists with `HR_ASSISTANT_SYSTEM_PROMPT`
    - `src/lib/ai/conversation.ts` exists with all functions
    - TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>
    - System prompt with tool usage guidelines
    - Grounding instructions to prevent hallucination
    - Conversation CRUD operations
    - Message history management with limit
    - Auto-title from first user message
  </done>
</task>

<task type="auto">
  <name>Task 2: Create streaming chat API route</name>
  <files>
    src/app/api/chat/route.ts
  </files>
  <action>
Create `src/app/api/chat/route.ts` with streaming chat and tool calling:

```typescript
import { streamText, type CoreMessage } from 'ai';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { chatModel } from '@/lib/ai/ollama-client';
import { HR_ASSISTANT_SYSTEM_PROMPT } from '@/lib/ai/prompts';
import { createEmployeeDataTools, getToolContext } from '@/lib/ai/tools';
import { createPolicySearchTool } from '@/lib/ai/tools/policy-search';
import {
  getOrCreateConversation,
  getConversationHistory,
  saveMessage,
} from '@/lib/ai/conversation';

export const maxDuration = 60; // 60 second timeout for streaming

export async function POST(req: Request) {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse request
    const { messages, conversationId } = await req.json() as {
      messages: CoreMessage[];
      conversationId?: string;
    };

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return Response.json({ error: 'Messages required' }, { status: 400 });
    }

    // Get last user message
    const lastMessage = messages[messages.length - 1];
    if (lastMessage.role !== 'user') {
      return Response.json({ error: 'Last message must be from user' }, { status: 400 });
    }

    // Get or create conversation
    const { id: convId, isNew } = await getOrCreateConversation(
      session.user.id,
      conversationId
    );

    // Save user message
    await saveMessage(convId, 'user', lastMessage.content as string);

    // Build context for tools
    const toolContext = await getToolContext();
    if (!toolContext) {
      return Response.json({ error: 'Unable to load user context' }, { status: 500 });
    }

    // Get employee name for personalization
    const employee = toolContext.employeeId
      ? await prisma.employee.findUnique({
          where: { id: toolContext.employeeId },
          select: { first_name: true },
        })
      : null;

    // Get conversation history
    const history = await getConversationHistory(convId);

    // Combine history with current messages
    // Filter out the last user message since we'll send it from the client
    const fullMessages: CoreMessage[] = [
      ...history.slice(0, -1).map((m) => ({
        role: m.role as CoreMessage['role'],
        content: m.content,
      })),
      ...messages,
    ];

    // Create tools with context
    const employeeTools = createEmployeeDataTools(toolContext);
    const policyTools = createPolicySearchTool({ role: toolContext.role });

    // Combine all tools
    const tools = {
      ...employeeTools,
      ...policyTools,
    };

    // Create personalized system prompt
    const systemPrompt = employee
      ? `${HR_ASSISTANT_SYSTEM_PROMPT}\n\nYou are assisting ${employee.first_name}.`
      : HR_ASSISTANT_SYSTEM_PROMPT;

    // Stream response
    const result = streamText({
      model: chatModel,
      system: systemPrompt,
      messages: fullMessages,
      tools,
      maxSteps: 5, // Prevent infinite tool call loops
      onFinish: async ({ text, toolCalls }) => {
        // Save assistant response
        await saveMessage(convId, 'assistant', text, toolCalls);
      },
    });

    // Return streaming response with conversation ID in header
    const response = result.toDataStreamResponse();

    // Add conversation ID to response headers
    const headers = new Headers(response.headers);
    headers.set('X-Conversation-Id', convId);

    return new Response(response.body, {
      status: response.status,
      headers,
    });
  } catch (error) {
    console.error('Chat API error:', error);
    return Response.json(
      { error: error instanceof Error ? error.message : 'Chat failed' },
      { status: 500 }
    );
  }
}
```

**Important patterns used:**
- `streamText` from AI SDK for streaming responses
- Tool calling with `maxSteps: 5` to prevent loops
- Conversation ID in response header for client to use
- `onFinish` callback to save assistant response
- Personalized system prompt with employee name
  </action>
  <verify>
    - `src/app/api/chat/route.ts` exists
    - Exports POST handler
    - Uses streamText from AI SDK
    - Combines employee data and policy search tools
    - TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>
    - Streaming chat API with tool calling
    - Conversation persistence
    - RBAC through tool context (not prompts)
    - Personalized responses with employee name
    - maxSteps limit to prevent tool call loops
    - Conversation ID returned in header
  </done>
</task>

<task type="auto">
  <name>Task 3: Create conversation and policy management APIs</name>
  <files>
    src/app/api/conversations/route.ts
    src/app/api/conversations/[id]/route.ts
    src/app/api/policies/route.ts
    src/app/api/policies/[id]/route.ts
  </files>
  <action>
1. Create `src/app/api/conversations/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { listConversations } from '@/lib/ai/conversation';

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const conversations = await listConversations(session.user.id);

  return NextResponse.json({ conversations });
}
```

2. Create `src/app/api/conversations/[id]/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { deleteConversation } from '@/lib/ai/conversation';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  const conversation = await prisma.conversation.findFirst({
    where: {
      id,
      user_id: session.user.id,
    },
    include: {
      messages: {
        orderBy: { created_at: 'asc' },
        select: {
          id: true,
          role: true,
          content: true,
          created_at: true,
        },
      },
    },
  });

  if (!conversation) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }

  return NextResponse.json({ conversation });
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;
  const deleted = await deleteConversation(session.user.id, id);

  if (!deleted) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }

  return NextResponse.json({ success: true });
}
```

3. Create `src/app/api/policies/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { z } from 'zod';
import { addEmbeddingJob } from '@/lib/queues/embedding.queue';

const ADMIN_ROLES = ['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'];

const createPolicySchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().optional(),
  category: z.enum(['LEAVE', 'PAYROLL', 'ATTENDANCE', 'EXPENSE', 'GENERAL']),
  content: z.string().min(10),
  visibleToRoles: z.array(z.string()).optional().default([]),
});

export async function GET(request: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const category = searchParams.get('category');

  // Get user role
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  if (!user) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  // Build where clause
  const where: Record<string, unknown> = { is_active: true };

  if (category) {
    where.category = category;
  }

  // Non-admins only see policies visible to their role or all
  if (!ADMIN_ROLES.includes(user.role)) {
    where.OR = [
      { visible_to_roles: { isEmpty: true } },
      { visible_to_roles: { hasSome: [user.role, 'ALL'] } },
    ];
  }

  const policies = await prisma.policyDocument.findMany({
    where,
    orderBy: { updated_at: 'desc' },
    select: {
      id: true,
      title: true,
      description: true,
      category: true,
      embedding_status: true,
      chunk_count: true,
      last_embedded_at: true,
      created_at: true,
      updated_at: true,
    },
  });

  return NextResponse.json({ policies });
}

export async function POST(request: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Only admins can create policies
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  if (!user || !ADMIN_ROLES.includes(user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const body = await request.json();
  const parsed = createPolicySchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      { error: 'Validation failed', details: parsed.error.flatten() },
      { status: 400 }
    );
  }

  const { title, description, category, content, visibleToRoles } = parsed.data;

  // Create policy document
  const policy = await prisma.policyDocument.create({
    data: {
      title,
      description,
      category,
      content,
      visible_to_roles: visibleToRoles,
      created_by: session.user.id,
      updated_by: session.user.id,
    },
  });

  // Queue embedding job
  await addEmbeddingJob({
    policyId: policy.id,
    title: policy.title,
    category: policy.category,
    content: policy.content,
    visibleToRoles: policy.visible_to_roles,
  });

  return NextResponse.json({ policy }, { status: 201 });
}
```

4. Create `src/app/api/policies/[id]/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { z } from 'zod';
import { addEmbeddingJob } from '@/lib/queues/embedding.queue';
import { qdrant, POLICIES_COLLECTION } from '@/lib/qdrant/client';

const ADMIN_ROLES = ['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'];

const updatePolicySchema = z.object({
  title: z.string().min(1).max(200).optional(),
  description: z.string().optional(),
  category: z.enum(['LEAVE', 'PAYROLL', 'ATTENDANCE', 'EXPENSE', 'GENERAL']).optional(),
  content: z.string().min(10).optional(),
  visibleToRoles: z.array(z.string()).optional(),
  isActive: z.boolean().optional(),
});

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  const policy = await prisma.policyDocument.findUnique({
    where: { id },
  });

  if (!policy) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }

  return NextResponse.json({ policy });
}

export async function PATCH(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  if (!user || !ADMIN_ROLES.includes(user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;
  const body = await request.json();
  const parsed = updatePolicySchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      { error: 'Validation failed', details: parsed.error.flatten() },
      { status: 400 }
    );
  }

  const existing = await prisma.policyDocument.findUnique({
    where: { id },
  });

  if (!existing) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }

  const { title, description, category, content, visibleToRoles, isActive } = parsed.data;

  // Check if content changed (requires re-embedding)
  const contentChanged = content && content !== existing.content;

  const policy = await prisma.policyDocument.update({
    where: { id },
    data: {
      title,
      description,
      category,
      content,
      visible_to_roles: visibleToRoles,
      is_active: isActive,
      updated_by: session.user.id,
      // Reset embedding status if content changed
      ...(contentChanged && {
        embedding_status: 'PENDING',
        chunk_count: 0,
        last_embedded_at: null,
      }),
    },
  });

  // Re-queue embedding if content changed
  if (contentChanged) {
    await addEmbeddingJob({
      policyId: policy.id,
      title: policy.title,
      category: policy.category,
      content: policy.content,
      visibleToRoles: policy.visible_to_roles,
    });
  }

  return NextResponse.json({ policy });
}

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true },
  });

  if (!user || !ADMIN_ROLES.includes(user.role)) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const { id } = await params;

  // Delete from Qdrant first
  try {
    await qdrant.delete(POLICIES_COLLECTION, {
      filter: {
        must: [{ key: 'policyId', match: { value: id } }],
      },
    });
  } catch (e) {
    console.error('Failed to delete from Qdrant:', e);
    // Continue with Prisma delete even if Qdrant fails
  }

  // Delete from Prisma
  await prisma.policyDocument.delete({
    where: { id },
  });

  return NextResponse.json({ success: true });
}
```
  </action>
  <verify>
    - All API routes exist and export correct handlers
    - TypeScript compiles: `pnpm tsc --noEmit`
    - Conversation APIs have auth checks
    - Policy APIs have RBAC (admin only for write)
    - Policy create/update triggers embedding job
  </verify>
  <done>
    - Conversation list and detail APIs
    - Conversation delete API
    - Policy CRUD APIs with RBAC
    - Policy create/update triggers embedding job
    - Policy delete removes from Qdrant
    - All endpoints authenticated
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `pnpm tsc --noEmit`
2. Chat API endpoint exists: `cat src/app/api/chat/route.ts`
3. Conversation APIs exist: `ls src/app/api/conversations/`
4. Policy APIs exist: `ls src/app/api/policies/`
5. Tool integration in chat route (grep for createEmployeeDataTools)
</verification>

<success_criteria>
- Streaming chat API with tool calling
- System prompt with grounding instructions
- Conversation CRUD operations
- Message history with limit (20 messages)
- Policy document CRUD with RBAC
- Policy create/update triggers embedding job
- All TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-assistant/06-04-SUMMARY.md`
</output>
