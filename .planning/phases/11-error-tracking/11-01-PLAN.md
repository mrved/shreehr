# Phase 11-01: Error Capture & Notification Implementation Plan

**Status:** âœ… COMPLETED (2026-02-04)  
**Estimated Effort:** 4-6 hours  
**Dependencies:** None (OpenClaw already available for WhatsApp)

---

## Objective

When errors occur in production ShreeHR, automatically notify Ved via WhatsApp with relevant context. Prevent notification spam through smart deduplication and rate limiting.

---

## Implementation Steps

### Step 1: Database Schema (15 min)

Add ErrorLog model to Prisma schema:

```prisma
model ErrorLog {
  id          String   @id @default(cuid())
  fingerprint String   @db.VarChar(64)
  error_type  String   @db.VarChar(50)  // API, CLIENT, AI_CHAT, AUTH, PAYROLL
  severity    String   @db.VarChar(20)  // CRITICAL, HIGH, MEDIUM, LOW
  message     String   @db.Text
  stack       String?  @db.Text
  route       String?  @db.VarChar(255)
  method      String?  @db.VarChar(10)  // GET, POST, etc
  user_id     String?  @db.VarChar(50)
  employee_id String?
  metadata    Json?
  notified    Boolean  @default(false)
  created_at  DateTime @default(now())

  @@index([fingerprint])
  @@index([created_at])
  @@index([error_type, severity])
}
```

**Files:** `prisma/schema.prisma`

---

### Step 2: Error Logger Utility (45 min)

Create `src/lib/error-logger.ts`:

```typescript
interface ErrorLogInput {
  type: 'API' | 'CLIENT' | 'AI_CHAT' | 'AUTH' | 'PAYROLL';
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  message: string;
  stack?: string;
  route?: string;
  method?: string;
  userId?: string;
  employeeId?: string;
  metadata?: Record<string, unknown>;
}

export async function logError(input: ErrorLogInput): Promise<void>
export function createFingerprint(type: string, message: string, route?: string): string
export async function shouldNotify(fingerprint: string, severity: string): Promise<boolean>
export async function sendWhatsAppNotification(error: ErrorLogInput): Promise<void>
```

**Key Logic:**
- Generate fingerprint from error type + normalized message + route
- Check if same fingerprint notified in last hour
- Check global rate limit (max 10/hour)
- Respect quiet hours (23:00-08:00) for non-CRITICAL
- Store in DB regardless of notification decision

---

### Step 3: WhatsApp Notification Function (30 min)

Create `src/lib/notifications/whatsapp-error.ts`:

```typescript
const OPENCLAW_WEBHOOK_URL = process.env.OPENCLAW_WEBHOOK_URL;

export async function notifyVedOfError(error: {
  type: string;
  severity: string;
  message: string;
  route?: string;
  timestamp: Date;
}): Promise<void> {
  // Format message
  const emoji = severity === 'CRITICAL' ? 'ðŸš¨' : severity === 'HIGH' ? 'âš ï¸' : 'ðŸ“‹';
  const text = `${emoji} **ShreeHR Error**

**Type:** ${error.type}
**Severity:** ${error.severity}
**Route:** ${error.route || 'N/A'}
**Time:** ${error.timestamp.toISOString()}

**Message:**
${error.message.slice(0, 500)}`;

  // POST to OpenClaw webhook
  await fetch(OPENCLAW_WEBHOOK_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message: text, target: 'ved' })
  });
}
```

**Env Variable:** `OPENCLAW_WEBHOOK_URL`

---

### Step 4: API Route Wrapper (30 min)

Create `src/lib/api-error-handler.ts`:

```typescript
export function withErrorLogging(
  handler: (req: Request, ctx?: any) => Promise<Response>,
  options: { route: string; critical?: boolean }
) {
  return async (req: Request, ctx?: any) => {
    try {
      const response = await handler(req, ctx);
      
      // Log 5xx responses
      if (response.status >= 500) {
        await logError({
          type: 'API',
          severity: options.critical ? 'CRITICAL' : 'HIGH',
          message: `API returned ${response.status}`,
          route: options.route,
          method: req.method,
        });
      }
      
      return response;
    } catch (error) {
      await logError({
        type: 'API',
        severity: options.critical ? 'CRITICAL' : 'HIGH',
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        route: options.route,
        method: req.method,
      });
      
      return Response.json({ error: 'Internal error' }, { status: 500 });
    }
  };
}
```

**Usage in API routes:**
```typescript
// Before
export async function POST(req: Request) { ... }

// After
export const POST = withErrorLogging(
  async (req: Request) => { ... },
  { route: '/api/chat', critical: true }
);
```

---

### Step 5: Client-Side Error Boundary (30 min)

Create `src/app/global-error.tsx`:

```typescript
'use client';

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Report to API endpoint
    fetch('/api/errors/client', {
      method: 'POST',
      body: JSON.stringify({
        message: error.message,
        stack: error.stack,
        digest: error.digest,
      }),
    }).catch(console.error);
  }, [error]);

  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  );
}
```

Create `src/app/api/errors/client/route.ts` to receive client errors.

---

### Step 6: AI Chat Error Enhancement (20 min)

Update `src/app/api/chat/route.ts`:

```typescript
// In catch block, add:
await logError({
  type: 'AI_CHAT',
  severity: 'CRITICAL',  // AI failures are critical
  message: errorMessage,
  route: '/api/chat',
  method: 'POST',
  userId: session.user.id,
  metadata: {
    provider: providerInfo.provider,
    model: providerInfo.model,
  },
});
```

---

### Step 7: Critical Route Identification (15 min)

**CRITICAL routes (immediate notification):**
- `/api/chat` - AI assistant failure
- `/api/auth/*` - Login/session issues
- `/api/payroll/*` - Payroll calculation failures
- `/api/attendance/check-*` - Check-in/out failures

**HIGH routes (quick notification):**
- `/api/employees/*` - Employee data operations
- `/api/leave/*` - Leave management

**MEDIUM routes (batched daily):**
- Everything else

---

### Step 8: Rate Limiting Implementation (30 min)

In `src/lib/error-logger.ts`:

```typescript
const RATE_LIMITS = {
  perFingerprint: 60 * 60 * 1000,  // 1 hour
  globalMax: 10,                    // per hour
  quietHoursStart: 23,
  quietHoursEnd: 8,
};

async function shouldNotify(fingerprint: string, severity: string): Promise<boolean> {
  const now = new Date();
  const hour = now.getHours();
  
  // Quiet hours check (except CRITICAL)
  if (severity !== 'CRITICAL' && (hour >= 23 || hour < 8)) {
    return false;
  }
  
  // Check fingerprint rate limit
  const recent = await prisma.errorLog.findFirst({
    where: {
      fingerprint,
      notified: true,
      created_at: { gte: new Date(Date.now() - RATE_LIMITS.perFingerprint) },
    },
  });
  if (recent) return false;
  
  // Check global rate limit
  const globalCount = await prisma.errorLog.count({
    where: {
      notified: true,
      created_at: { gte: new Date(Date.now() - 60 * 60 * 1000) },
    },
  });
  if (globalCount >= RATE_LIMITS.globalMax) return false;
  
  return true;
}
```

---

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `prisma/schema.prisma` | MODIFY | Add ErrorLog model |
| `src/lib/error-logger.ts` | CREATE | Core error logging utility |
| `src/lib/notifications/whatsapp-error.ts` | CREATE | WhatsApp notification function |
| `src/lib/api-error-handler.ts` | CREATE | API route wrapper |
| `src/app/global-error.tsx` | CREATE | Client error boundary |
| `src/app/api/errors/client/route.ts` | CREATE | Client error receiver |
| `src/app/api/chat/route.ts` | MODIFY | Add error logging |
| `.env` | MODIFY | Add OPENCLAW_WEBHOOK_URL |

---

## Environment Variables

```env
# Error Notification
OPENCLAW_WEBHOOK_URL=https://your-openclaw-instance/webhook/shreehr-errors
ERROR_NOTIFY_ENABLED=true
```

---

## Testing Plan

1. **Unit Test:** Error fingerprinting consistency
2. **Unit Test:** Rate limiting logic
3. **Integration Test:** Error â†’ DB â†’ Notification flow
4. **Manual Test:** Trigger intentional error, verify WhatsApp received

---

## Rollout Plan

1. Deploy with `ERROR_NOTIFY_ENABLED=false` initially
2. Monitor logs for a day to verify capture working
3. Enable notifications
4. Fine-tune rate limits based on actual error volume

---

## Success Criteria

- [x] Errors captured in ErrorLog table
- [x] CRITICAL errors marked for notification (Pip picks up via heartbeat)
- [x] Same error doesn't spam (deduplication works via fingerprinting)
- [x] No notifications during quiet hours (except CRITICAL)
- [x] AI chat failures specifically captured and notified

---

## Future Enhancements (Not in Scope)

- Admin UI to browse errors
- Email digest of daily errors
- Slack integration option
- Error trends/analytics dashboard

---

## Questions for Ved

1. **Quiet hours:** 23:00-08:00 IST okay? Or different times?
2. **OpenClaw webhook:** Do you have one set up, or should we use a different approach?
3. **Rate limit:** 10 messages/hour max okay? Could adjust.
4. **Which routes are truly CRITICAL?** I've guessed based on business logic.

---

**Ready for approval. No execution until Ved confirms.**
