---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/app/api/documents/route.ts
  - src/app/api/documents/[id]/route.ts
  - src/app/api/documents/[id]/download/route.ts
  - src/app/api/import/employees/route.ts
  - src/app/api/import/salary/route.ts
  - src/app/api/import/leave/route.ts
  - src/app/(dashboard)/documents/page.tsx
  - src/app/(dashboard)/import/page.tsx
  - src/components/documents/document-upload.tsx
  - src/components/import/keka-import.tsx
  - src/lib/storage.ts
  - src/lib/parsers/keka.ts
autonomous: true

must_haves:
  truths:
    - "Admin can upload employee documents (offer letter, ID proofs, certificates)"
    - "Documents are stored with 8-year retention date calculated from upload"
    - "Admin can download stored documents"
    - "Admin can import employees from Keka HR CSV export"
    - "Admin can import salary history from Keka for Form 16 continuity"
    - "Admin can import leave balances from Keka"
    - "Import validates data and reports errors without failing entire batch"
  artifacts:
    - path: "src/app/api/documents/route.ts"
      provides: "Document upload API"
      exports: ["GET", "POST"]
    - path: "src/lib/storage.ts"
      provides: "File storage utilities"
      exports: ["saveFile", "getFilePath", "deleteFile"]
    - path: "src/lib/parsers/keka.ts"
      provides: "Keka CSV parser"
      exports: ["parseKekaEmployees", "parseKekaSalary", "parseKekaLeave"]
    - path: "src/components/import/keka-import.tsx"
      provides: "Keka import UI"
      min_lines: 100
  key_links:
    - from: "src/app/api/documents/route.ts"
      to: "src/lib/storage.ts"
      via: "saveFile function"
      pattern: "saveFile\\("
    - from: "src/app/api/import/employees/route.ts"
      to: "src/lib/parsers/keka.ts"
      via: "parseKekaEmployees"
      pattern: "parseKekaEmployees"
---

<objective>
Implement document storage with 8-year retention and Keka HR data import (employees, salary history, leave balances).

Purpose: Enable document compliance (8-year retention for labor law) and complete migration from Keka HR with historical data for Form 16 continuity.

Output: Document upload/download, Keka CSV import with validation, import history tracking.
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@prisma/schema.prisma
@src/lib/db.ts
@src/lib/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document storage system with 8-year retention</name>
  <files>
    src/lib/storage.ts
    src/app/api/documents/route.ts
    src/app/api/documents/[id]/route.ts
    src/app/api/documents/[id]/download/route.ts
  </files>
  <action>
    Create src/lib/storage.ts for file storage:
    ```typescript
    import { mkdir, writeFile, unlink, access, readFile } from 'fs/promises';
    import { join } from 'path';
    import { randomBytes } from 'crypto';

    // Base directory for file storage
    const UPLOAD_DIR = process.env.UPLOAD_DIR || './uploads';

    // 8 years in milliseconds for retention calculation
    const RETENTION_YEARS = 8;
    const MS_PER_YEAR = 365.25 * 24 * 60 * 60 * 1000;

    /**
     * Calculate retention date (8 years from upload)
     */
    export function calculateRetentionDate(uploadDate: Date = new Date()): Date {
      return new Date(uploadDate.getTime() + RETENTION_YEARS * MS_PER_YEAR);
    }

    /**
     * Generate a unique filename to prevent collisions
     */
    export function generateUniqueFilename(originalName: string): string {
      const ext = originalName.split('.').pop() || '';
      const uniqueId = randomBytes(16).toString('hex');
      const timestamp = Date.now();
      return `${timestamp}-${uniqueId}.${ext}`;
    }

    /**
     * Get storage path for an employee's documents
     */
    function getEmployeeDir(employeeId: string): string {
      return join(UPLOAD_DIR, 'employees', employeeId);
    }

    /**
     * Save a file to storage
     */
    export async function saveFile(
      employeeId: string,
      file: Buffer,
      originalName: string
    ): Promise<{ fileName: string; storagePath: string }> {
      const employeeDir = getEmployeeDir(employeeId);

      // Ensure directory exists
      await mkdir(employeeDir, { recursive: true });

      const fileName = generateUniqueFilename(originalName);
      const storagePath = join(employeeDir, fileName);

      await writeFile(storagePath, file);

      return { fileName, storagePath };
    }

    /**
     * Get a file from storage
     */
    export async function getFile(storagePath: string): Promise<Buffer | null> {
      try {
        await access(storagePath);
        return await readFile(storagePath);
      } catch {
        return null;
      }
    }

    /**
     * Delete a file from storage (soft delete - file remains until retention expires)
     */
    export async function deleteFile(storagePath: string): Promise<boolean> {
      try {
        await access(storagePath);
        await unlink(storagePath);
        return true;
      } catch {
        return false;
      }
    }

    /**
     * Get allowed MIME types for document uploads
     */
    export const ALLOWED_MIME_TYPES = [
      'application/pdf',
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    ];

    /**
     * Maximum file size (10MB)
     */
    export const MAX_FILE_SIZE = 10 * 1024 * 1024;

    /**
     * Validate file upload
     */
    export function validateFile(
      mimeType: string,
      size: number
    ): { valid: boolean; error?: string } {
      if (!ALLOWED_MIME_TYPES.includes(mimeType)) {
        return { valid: false, error: 'File type not allowed. Use PDF, JPG, PNG, or DOC.' };
      }
      if (size > MAX_FILE_SIZE) {
        return { valid: false, error: 'File size exceeds 10MB limit.' };
      }
      return { valid: true };
    }
    ```

    Create src/app/api/documents/route.ts:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@/lib/auth';
    import { prisma } from '@/lib/db';
    import {
      saveFile,
      calculateRetentionDate,
      validateFile,
      ALLOWED_MIME_TYPES,
    } from '@/lib/storage';

    export async function GET(request: NextRequest) {
      const session = await auth();
      if (!session?.user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      const searchParams = request.nextUrl.searchParams;
      const employeeId = searchParams.get('employeeId');
      const type = searchParams.get('type');

      const where: any = { isDeleted: false };

      if (employeeId) {
        // Access control
        if (session.user.role === 'EMPLOYEE' && session.user.employeeId !== employeeId) {
          return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
        }
        where.employeeId = employeeId;
      } else if (session.user.role === 'EMPLOYEE') {
        where.employeeId = session.user.employeeId;
      }

      if (type) {
        where.type = type;
      }

      const documents = await prisma.document.findMany({
        where,
        orderBy: { uploadedAt: 'desc' },
        include: {
          employee: { select: { id: true, firstName: true, lastName: true, employeeCode: true } },
        },
      });

      return NextResponse.json(documents);
    }

    export async function POST(request: NextRequest) {
      const session = await auth();
      if (!session?.user || session.user.role !== 'ADMIN') {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const formData = await request.formData();
        const file = formData.get('file') as File;
        const employeeId = formData.get('employeeId') as string;
        const type = formData.get('type') as string;
        const description = formData.get('description') as string | null;

        if (!file || !employeeId || !type) {
          return NextResponse.json(
            { error: 'Missing required fields: file, employeeId, type' },
            { status: 400 }
          );
        }

        // Validate file
        const validation = validateFile(file.type, file.size);
        if (!validation.valid) {
          return NextResponse.json({ error: validation.error }, { status: 400 });
        }

        // Check employee exists
        const employee = await prisma.employee.findUnique({
          where: { id: employeeId },
        });
        if (!employee) {
          return NextResponse.json({ error: 'Employee not found' }, { status: 404 });
        }

        // Save file
        const fileBuffer = Buffer.from(await file.arrayBuffer());
        const { fileName, storagePath } = await saveFile(employeeId, fileBuffer, file.name);

        // Create document record
        const uploadedAt = new Date();
        const document = await prisma.document.create({
          data: {
            employeeId,
            type: type as any,
            fileName,
            originalName: file.name,
            mimeType: file.type,
            fileSize: file.size,
            storagePath,
            description,
            uploadedAt,
            retentionUntil: calculateRetentionDate(uploadedAt),
            createdBy: session.user.id,
            updatedBy: session.user.id,
          },
        });

        return NextResponse.json(document, { status: 201 });
      } catch (error) {
        console.error('Document upload error:', error);
        return NextResponse.json({ error: 'Upload failed' }, { status: 500 });
      }
    }
    ```

    Create src/app/api/documents/[id]/route.ts:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@/lib/auth';
    import { prisma } from '@/lib/db';

    export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const session = await auth();
      if (!session?.user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      const { id } = await params;

      const document = await prisma.document.findUnique({
        where: { id },
        include: {
          employee: { select: { id: true, firstName: true, lastName: true } },
        },
      });

      if (!document || document.isDeleted) {
        return NextResponse.json({ error: 'Not found' }, { status: 404 });
      }

      // Access control
      if (
        session.user.role === 'EMPLOYEE' &&
        session.user.employeeId !== document.employeeId
      ) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      }

      return NextResponse.json(document);
    }

    export async function DELETE(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const session = await auth();
      if (!session?.user || session.user.role !== 'ADMIN') {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      const { id } = await params;

      // Soft delete - mark as deleted but keep file until retention expires
      await prisma.document.update({
        where: { id },
        data: {
          isDeleted: true,
          deletedAt: new Date(),
          updatedBy: session.user.id,
        },
      });

      return NextResponse.json({ success: true });
    }
    ```

    Create src/app/api/documents/[id]/download/route.ts:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@/lib/auth';
    import { prisma } from '@/lib/db';
    import { getFile } from '@/lib/storage';

    export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const session = await auth();
      if (!session?.user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      const { id } = await params;

      const document = await prisma.document.findUnique({
        where: { id },
      });

      if (!document || document.isDeleted) {
        return NextResponse.json({ error: 'Not found' }, { status: 404 });
      }

      // Access control
      if (
        session.user.role === 'EMPLOYEE' &&
        session.user.employeeId !== document.employeeId
      ) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      }

      const fileBuffer = await getFile(document.storagePath);
      if (!fileBuffer) {
        return NextResponse.json({ error: 'File not found on storage' }, { status: 404 });
      }

      return new NextResponse(fileBuffer, {
        headers: {
          'Content-Type': document.mimeType,
          'Content-Disposition': `attachment; filename="${document.originalName}"`,
          'Content-Length': document.fileSize.toString(),
        },
      });
    }
    ```
  </action>
  <verify>
    `pnpm tsc --noEmit` - no TypeScript errors
    Test API with multipart form upload:
    - POST /api/documents with file, employeeId, type
    - GET /api/documents?employeeId=xxx returns list
    - GET /api/documents/:id/download returns file
  </verify>
  <done>
    Document storage with local filesystem, 8-year retention calculation, upload validation, download endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Keka HR CSV parsers and import APIs</name>
  <files>
    src/lib/parsers/keka.ts
    src/app/api/import/employees/route.ts
    src/app/api/import/salary/route.ts
    src/app/api/import/leave/route.ts
  </files>
  <action>
    Install csv-parse for CSV parsing:
    ```bash
    pnpm add csv-parse
    ```

    Create src/lib/parsers/keka.ts:
    ```typescript
    import { parse } from 'csv-parse/sync';

    interface ParseResult<T> {
      data: T[];
      errors: { row: number; field: string; message: string }[];
    }

    interface KekaEmployee {
      employeeCode: string;
      firstName: string;
      lastName: string;
      dateOfBirth: Date;
      gender: 'MALE' | 'FEMALE' | 'OTHER';
      personalEmail?: string;
      workEmail: string;
      phone: string;
      dateOfJoining: Date;
      department?: string;
      designation?: string;
      reportingManagerCode?: string;
      panNumber?: string;
      bankAccountNumber?: string;
      bankIfscCode?: string;
      bankName?: string;
      uanNumber?: string;
      state?: string;
    }

    interface KekaSalary {
      employeeCode: string;
      month: number;
      year: number;
      basicPay: number;
      hra: number;
      conveyance: number;
      specialAllowance: number;
      otherAllowances: number;
      grossSalary: number;
      pfEmployee: number;
      pfEmployer: number;
      esiEmployee: number;
      esiEmployer: number;
      professionalTax: number;
      tds: number;
      otherDeductions: number;
      netSalary: number;
    }

    interface KekaLeaveBalance {
      employeeCode: string;
      leaveType: string;
      year: number;
      opening: number;
      accrued: number;
      used: number;
      balance: number;
    }

    /**
     * Parse Keka employee export CSV
     * Expected columns: Employee Code, First Name, Last Name, Date of Birth, Gender,
     * Personal Email, Work Email, Phone, Date of Joining, Department, Designation,
     * Reporting Manager Code, PAN, Bank Account, IFSC, Bank Name, UAN, State
     */
    export function parseKekaEmployees(csvContent: string): ParseResult<KekaEmployee> {
      const records = parse(csvContent, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
      });

      const data: KekaEmployee[] = [];
      const errors: { row: number; field: string; message: string }[] = [];

      records.forEach((record: any, index: number) => {
        const row = index + 2; // 1-based, plus header

        try {
          // Required fields
          const employeeCode = record['Employee Code']?.trim();
          const firstName = record['First Name']?.trim();
          const lastName = record['Last Name']?.trim();
          const workEmail = record['Work Email']?.trim();
          const phone = record['Phone']?.trim();
          const dobStr = record['Date of Birth']?.trim();
          const dojStr = record['Date of Joining']?.trim();

          if (!employeeCode) {
            errors.push({ row, field: 'Employee Code', message: 'Required' });
            return;
          }
          if (!firstName) {
            errors.push({ row, field: 'First Name', message: 'Required' });
            return;
          }
          if (!lastName) {
            errors.push({ row, field: 'Last Name', message: 'Required' });
            return;
          }
          if (!workEmail) {
            errors.push({ row, field: 'Work Email', message: 'Required' });
            return;
          }

          // Parse dates (handle multiple formats: DD/MM/YYYY, YYYY-MM-DD)
          const dateOfBirth = parseDate(dobStr);
          const dateOfJoining = parseDate(dojStr);

          if (!dateOfBirth) {
            errors.push({ row, field: 'Date of Birth', message: 'Invalid date format' });
            return;
          }
          if (!dateOfJoining) {
            errors.push({ row, field: 'Date of Joining', message: 'Invalid date format' });
            return;
          }

          // Parse gender
          const genderRaw = record['Gender']?.trim().toUpperCase();
          let gender: 'MALE' | 'FEMALE' | 'OTHER' = 'MALE';
          if (genderRaw === 'FEMALE' || genderRaw === 'F') gender = 'FEMALE';
          else if (genderRaw === 'OTHER' || genderRaw === 'O') gender = 'OTHER';

          data.push({
            employeeCode,
            firstName,
            lastName,
            dateOfBirth,
            gender,
            personalEmail: record['Personal Email']?.trim() || undefined,
            workEmail,
            phone: phone || '',
            dateOfJoining,
            department: record['Department']?.trim() || undefined,
            designation: record['Designation']?.trim() || undefined,
            reportingManagerCode: record['Reporting Manager Code']?.trim() || undefined,
            panNumber: record['PAN']?.trim() || undefined,
            bankAccountNumber: record['Bank Account']?.trim() || undefined,
            bankIfscCode: record['IFSC']?.trim() || undefined,
            bankName: record['Bank Name']?.trim() || undefined,
            uanNumber: record['UAN']?.trim() || undefined,
            state: record['State']?.trim() || undefined,
          });
        } catch (err) {
          errors.push({ row, field: 'general', message: 'Failed to parse row' });
        }
      });

      return { data, errors };
    }

    /**
     * Parse Keka salary export CSV
     * Expected columns: Employee Code, Month, Year, Basic, HRA, Conveyance,
     * Special Allowance, Other Allowances, Gross, PF Employee, PF Employer,
     * ESI Employee, ESI Employer, PT, TDS, Other Deductions, Net
     */
    export function parseKekaSalary(csvContent: string): ParseResult<KekaSalary> {
      const records = parse(csvContent, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
      });

      const data: KekaSalary[] = [];
      const errors: { row: number; field: string; message: string }[] = [];

      records.forEach((record: any, index: number) => {
        const row = index + 2;

        try {
          const employeeCode = record['Employee Code']?.trim();
          const month = parseInt(record['Month']);
          const year = parseInt(record['Year']);

          if (!employeeCode) {
            errors.push({ row, field: 'Employee Code', message: 'Required' });
            return;
          }
          if (isNaN(month) || month < 1 || month > 12) {
            errors.push({ row, field: 'Month', message: 'Invalid month (1-12)' });
            return;
          }
          if (isNaN(year) || year < 2000 || year > 2100) {
            errors.push({ row, field: 'Year', message: 'Invalid year' });
            return;
          }

          // Parse amounts (stored in paise for precision)
          const toPaise = (val: string) => Math.round(parseFloat(val || '0') * 100);

          data.push({
            employeeCode,
            month,
            year,
            basicPay: toPaise(record['Basic']),
            hra: toPaise(record['HRA']),
            conveyance: toPaise(record['Conveyance']),
            specialAllowance: toPaise(record['Special Allowance']),
            otherAllowances: toPaise(record['Other Allowances']),
            grossSalary: toPaise(record['Gross']),
            pfEmployee: toPaise(record['PF Employee']),
            pfEmployer: toPaise(record['PF Employer']),
            esiEmployee: toPaise(record['ESI Employee']),
            esiEmployer: toPaise(record['ESI Employer']),
            professionalTax: toPaise(record['PT']),
            tds: toPaise(record['TDS']),
            otherDeductions: toPaise(record['Other Deductions']),
            netSalary: toPaise(record['Net']),
          });
        } catch (err) {
          errors.push({ row, field: 'general', message: 'Failed to parse row' });
        }
      });

      return { data, errors };
    }

    /**
     * Parse Keka leave balance export CSV
     * Expected columns: Employee Code, Leave Type, Year, Opening, Accrued, Used, Balance
     */
    export function parseKekaLeave(csvContent: string): ParseResult<KekaLeaveBalance> {
      const records = parse(csvContent, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
      });

      const data: KekaLeaveBalance[] = [];
      const errors: { row: number; field: string; message: string }[] = [];

      records.forEach((record: any, index: number) => {
        const row = index + 2;

        try {
          const employeeCode = record['Employee Code']?.trim();
          const leaveType = record['Leave Type']?.trim();
          const year = parseInt(record['Year']);

          if (!employeeCode) {
            errors.push({ row, field: 'Employee Code', message: 'Required' });
            return;
          }
          if (!leaveType) {
            errors.push({ row, field: 'Leave Type', message: 'Required' });
            return;
          }

          data.push({
            employeeCode,
            leaveType,
            year: isNaN(year) ? new Date().getFullYear() : year,
            opening: parseFloat(record['Opening'] || '0'),
            accrued: parseFloat(record['Accrued'] || '0'),
            used: parseFloat(record['Used'] || '0'),
            balance: parseFloat(record['Balance'] || '0'),
          });
        } catch (err) {
          errors.push({ row, field: 'general', message: 'Failed to parse row' });
        }
      });

      return { data, errors };
    }

    // Helper to parse dates in multiple formats
    function parseDate(dateStr: string): Date | null {
      if (!dateStr) return null;

      // Try DD/MM/YYYY
      const ddmmyyyy = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (ddmmyyyy) {
        return new Date(parseInt(ddmmyyyy[3]), parseInt(ddmmyyyy[2]) - 1, parseInt(ddmmyyyy[1]));
      }

      // Try YYYY-MM-DD
      const isoDate = new Date(dateStr);
      if (!isNaN(isoDate.getTime())) {
        return isoDate;
      }

      return null;
    }
    ```

    Create src/app/api/import/employees/route.ts:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@/lib/auth';
    import { prisma } from '@/lib/db';
    import { parseKekaEmployees } from '@/lib/parsers/keka';
    import { encrypt } from '@/lib/encryption';

    export async function POST(request: NextRequest) {
      const session = await auth();
      if (!session?.user || session.user.role !== 'ADMIN') {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const formData = await request.formData();
        const file = formData.get('file') as File;

        if (!file) {
          return NextResponse.json({ error: 'No file provided' }, { status: 400 });
        }

        const csvContent = await file.text();
        const { data, errors } = parseKekaEmployees(csvContent);

        // Create import batch record
        const batch = await prisma.importBatch.create({
          data: {
            type: 'EMPLOYEES',
            fileName: file.name,
            status: 'PROCESSING',
            totalRecords: data.length,
            startedAt: new Date(),
            createdBy: session.user.id,
            updatedBy: session.user.id,
          },
        });

        let successCount = 0;
        const importErrors: any[] = [...errors];

        // Get or create departments and designations
        const deptMap = new Map<string, string>();
        const desigMap = new Map<string, string>();

        const uniqueDepts = [...new Set(data.map((e) => e.department).filter(Boolean))];
        const uniqueDesigs = [...new Set(data.map((e) => e.designation).filter(Boolean))];

        for (const deptName of uniqueDepts) {
          if (!deptName) continue;
          let dept = await prisma.department.findFirst({ where: { name: deptName } });
          if (!dept) {
            dept = await prisma.department.create({
              data: {
                name: deptName,
                code: deptName.substring(0, 10).toUpperCase().replace(/\s/g, ''),
                createdBy: session.user.id,
                updatedBy: session.user.id,
              },
            });
          }
          deptMap.set(deptName, dept.id);
        }

        for (const desigTitle of uniqueDesigs) {
          if (!desigTitle) continue;
          let desig = await prisma.designation.findFirst({ where: { title: desigTitle } });
          if (!desig) {
            desig = await prisma.designation.create({
              data: {
                title: desigTitle,
                createdBy: session.user.id,
                updatedBy: session.user.id,
              },
            });
          }
          desigMap.set(desigTitle, desig.id);
        }

        // Build employee code to ID map for manager assignments
        const empCodeMap = new Map<string, string>();
        const existingEmps = await prisma.employee.findMany({
          select: { id: true, employeeCode: true },
        });
        existingEmps.forEach((e) => empCodeMap.set(e.employeeCode, e.id));

        // First pass: create/update employees without manager
        for (const emp of data) {
          try {
            const empData: any = {
              firstName: emp.firstName,
              lastName: emp.lastName,
              dateOfBirth: emp.dateOfBirth,
              gender: emp.gender,
              personalEmail: emp.personalEmail || null,
              workEmail: emp.workEmail,
              phone: emp.phone,
              dateOfJoining: emp.dateOfJoining,
              state: emp.state || null,
              departmentId: emp.department ? deptMap.get(emp.department) : null,
              designationId: emp.designation ? desigMap.get(emp.designation) : null,
              panNumber: emp.panNumber ? encrypt(emp.panNumber) : null,
              bankAccountNumber: emp.bankAccountNumber ? encrypt(emp.bankAccountNumber) : null,
              bankIfscCode: emp.bankIfscCode || null,
              bankName: emp.bankName || null,
              uanNumber: emp.uanNumber || null,
              updatedBy: session.user.id,
            };

            const existing = await prisma.employee.findUnique({
              where: { employeeCode: emp.employeeCode },
            });

            if (existing) {
              await prisma.employee.update({
                where: { id: existing.id },
                data: empData,
              });
              empCodeMap.set(emp.employeeCode, existing.id);
            } else {
              const created = await prisma.employee.create({
                data: {
                  employeeCode: emp.employeeCode,
                  ...empData,
                  createdBy: session.user.id,
                },
              });
              empCodeMap.set(emp.employeeCode, created.id);
            }
            successCount++;
          } catch (err) {
            importErrors.push({
              row: data.indexOf(emp) + 2,
              field: 'employee',
              message: `Failed to create employee ${emp.employeeCode}: ${err instanceof Error ? err.message : 'Unknown error'}`,
            });
          }
        }

        // Second pass: update reporting managers
        for (const emp of data) {
          if (emp.reportingManagerCode && empCodeMap.has(emp.reportingManagerCode)) {
            try {
              await prisma.employee.update({
                where: { employeeCode: emp.employeeCode },
                data: { reportingManagerId: empCodeMap.get(emp.reportingManagerCode) },
              });
            } catch {
              // Ignore manager assignment errors
            }
          }
        }

        // Update batch record
        await prisma.importBatch.update({
          where: { id: batch.id },
          data: {
            status: importErrors.length > 0 ? 'COMPLETED' : 'COMPLETED',
            successCount,
            errorCount: importErrors.length,
            errors: importErrors.length > 0 ? importErrors : undefined,
            completedAt: new Date(),
          },
        });

        return NextResponse.json({
          batchId: batch.id,
          totalRecords: data.length,
          successCount,
          errorCount: importErrors.length,
          errors: importErrors.slice(0, 50), // Limit errors in response
        });
      } catch (error) {
        console.error('Employee import error:', error);
        return NextResponse.json({ error: 'Import failed' }, { status: 500 });
      }
    }
    ```

    Create src/app/api/import/salary/route.ts:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@/lib/auth';
    import { prisma } from '@/lib/db';
    import { parseKekaSalary } from '@/lib/parsers/keka';

    export async function POST(request: NextRequest) {
      const session = await auth();
      if (!session?.user || session.user.role !== 'ADMIN') {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const formData = await request.formData();
        const file = formData.get('file') as File;

        if (!file) {
          return NextResponse.json({ error: 'No file provided' }, { status: 400 });
        }

        const csvContent = await file.text();
        const { data, errors } = parseKekaSalary(csvContent);

        const batch = await prisma.importBatch.create({
          data: {
            type: 'SALARY_HISTORY',
            fileName: file.name,
            status: 'PROCESSING',
            totalRecords: data.length,
            startedAt: new Date(),
            createdBy: session.user.id,
            updatedBy: session.user.id,
          },
        });

        // Get employee code to ID mapping
        const employees = await prisma.employee.findMany({
          select: { id: true, employeeCode: true },
        });
        const empMap = new Map(employees.map((e) => [e.employeeCode, e.id]));

        let successCount = 0;
        const importErrors: any[] = [...errors];

        for (const salary of data) {
          const employeeId = empMap.get(salary.employeeCode);
          if (!employeeId) {
            importErrors.push({
              row: data.indexOf(salary) + 2,
              field: 'Employee Code',
              message: `Employee ${salary.employeeCode} not found`,
            });
            continue;
          }

          try {
            await prisma.salaryRecord.upsert({
              where: {
                employeeId_month_year: {
                  employeeId,
                  month: salary.month,
                  year: salary.year,
                },
              },
              update: {
                basicPay: salary.basicPay,
                hra: salary.hra,
                conveyance: salary.conveyance,
                specialAllowance: salary.specialAllowance,
                otherAllowances: salary.otherAllowances,
                grossSalary: salary.grossSalary,
                pfEmployee: salary.pfEmployee,
                pfEmployer: salary.pfEmployer,
                esiEmployee: salary.esiEmployee,
                esiEmployer: salary.esiEmployer,
                professionalTax: salary.professionalTax,
                tds: salary.tds,
                otherDeductions: salary.otherDeductions,
                netSalary: salary.netSalary,
                source: 'KEKA_IMPORT',
                importBatchId: batch.id,
                updatedBy: session.user.id,
              },
              create: {
                employeeId,
                month: salary.month,
                year: salary.year,
                basicPay: salary.basicPay,
                hra: salary.hra,
                conveyance: salary.conveyance,
                specialAllowance: salary.specialAllowance,
                otherAllowances: salary.otherAllowances,
                grossSalary: salary.grossSalary,
                pfEmployee: salary.pfEmployee,
                pfEmployer: salary.pfEmployer,
                esiEmployee: salary.esiEmployee,
                esiEmployer: salary.esiEmployer,
                professionalTax: salary.professionalTax,
                tds: salary.tds,
                otherDeductions: salary.otherDeductions,
                netSalary: salary.netSalary,
                source: 'KEKA_IMPORT',
                importBatchId: batch.id,
                createdBy: session.user.id,
                updatedBy: session.user.id,
              },
            });
            successCount++;
          } catch (err) {
            importErrors.push({
              row: data.indexOf(salary) + 2,
              field: 'salary',
              message: `Failed to import salary for ${salary.employeeCode} ${salary.month}/${salary.year}`,
            });
          }
        }

        await prisma.importBatch.update({
          where: { id: batch.id },
          data: {
            status: 'COMPLETED',
            successCount,
            errorCount: importErrors.length,
            errors: importErrors.length > 0 ? importErrors : undefined,
            completedAt: new Date(),
          },
        });

        return NextResponse.json({
          batchId: batch.id,
          totalRecords: data.length,
          successCount,
          errorCount: importErrors.length,
          errors: importErrors.slice(0, 50),
        });
      } catch (error) {
        console.error('Salary import error:', error);
        return NextResponse.json({ error: 'Import failed' }, { status: 500 });
      }
    }
    ```

    Create src/app/api/import/leave/route.ts:
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@/lib/auth';
    import { prisma } from '@/lib/db';
    import { parseKekaLeave } from '@/lib/parsers/keka';

    export async function POST(request: NextRequest) {
      const session = await auth();
      if (!session?.user || session.user.role !== 'ADMIN') {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const formData = await request.formData();
        const file = formData.get('file') as File;

        if (!file) {
          return NextResponse.json({ error: 'No file provided' }, { status: 400 });
        }

        const csvContent = await file.text();
        const { data, errors } = parseKekaLeave(csvContent);

        const batch = await prisma.importBatch.create({
          data: {
            type: 'LEAVE_BALANCES',
            fileName: file.name,
            status: 'PROCESSING',
            totalRecords: data.length,
            startedAt: new Date(),
            createdBy: session.user.id,
            updatedBy: session.user.id,
          },
        });

        const employees = await prisma.employee.findMany({
          select: { id: true, employeeCode: true },
        });
        const empMap = new Map(employees.map((e) => [e.employeeCode, e.id]));

        let successCount = 0;
        const importErrors: any[] = [...errors];

        for (const leave of data) {
          const employeeId = empMap.get(leave.employeeCode);
          if (!employeeId) {
            importErrors.push({
              row: data.indexOf(leave) + 2,
              field: 'Employee Code',
              message: `Employee ${leave.employeeCode} not found`,
            });
            continue;
          }

          try {
            await prisma.leaveBalance.upsert({
              where: {
                employeeId_leaveType_year: {
                  employeeId,
                  leaveType: leave.leaveType,
                  year: leave.year,
                },
              },
              update: {
                opening: leave.opening,
                accrued: leave.accrued,
                used: leave.used,
                balance: leave.balance,
                source: 'KEKA_IMPORT',
                importBatchId: batch.id,
                updatedBy: session.user.id,
              },
              create: {
                employeeId,
                leaveType: leave.leaveType,
                year: leave.year,
                opening: leave.opening,
                accrued: leave.accrued,
                used: leave.used,
                balance: leave.balance,
                source: 'KEKA_IMPORT',
                importBatchId: batch.id,
                createdBy: session.user.id,
                updatedBy: session.user.id,
              },
            });
            successCount++;
          } catch (err) {
            importErrors.push({
              row: data.indexOf(leave) + 2,
              field: 'leave',
              message: `Failed to import leave for ${leave.employeeCode}`,
            });
          }
        }

        await prisma.importBatch.update({
          where: { id: batch.id },
          data: {
            status: 'COMPLETED',
            successCount,
            errorCount: importErrors.length,
            errors: importErrors.length > 0 ? importErrors : undefined,
            completedAt: new Date(),
          },
        });

        return NextResponse.json({
          batchId: batch.id,
          totalRecords: data.length,
          successCount,
          errorCount: importErrors.length,
          errors: importErrors.slice(0, 50),
        });
      } catch (error) {
        console.error('Leave import error:', error);
        return NextResponse.json({ error: 'Import failed' }, { status: 500 });
      }
    }
    ```
  </action>
  <verify>
    `pnpm tsc --noEmit` - no TypeScript errors
    Create test CSV files and test import APIs:
    - POST /api/import/employees with CSV
    - POST /api/import/salary with CSV
    - POST /api/import/leave with CSV
  </verify>
  <done>
    Keka CSV parsers for employees, salary history, and leave balances.
    Import APIs with validation, error collection, batch tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create document and import UI pages</name>
  <files>
    src/app/(dashboard)/documents/page.tsx
    src/app/(dashboard)/import/page.tsx
    src/components/documents/document-upload.tsx
    src/components/import/keka-import.tsx
  </files>
  <action>
    Create src/components/documents/document-upload.tsx:
    ```typescript
    'use client';

    import { useState, useRef } from 'react';
    import { Button } from '@/components/ui/button';
    import { Label } from '@/components/ui/label';
    import { Input } from '@/components/ui/input';
    import {
      Select,
      SelectContent,
      SelectItem,
      SelectTrigger,
      SelectValue,
    } from '@/components/ui/select';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
    import { Upload, X } from 'lucide-react';
    import { DOCUMENT_TYPES } from '@/types';

    interface DocumentUploadProps {
      employeeId?: string;
      employees?: { id: string; firstName: string; lastName: string; employeeCode: string }[];
      onUploadComplete?: () => void;
    }

    export function DocumentUpload({ employeeId, employees, onUploadComplete }: DocumentUploadProps) {
      const [selectedEmployee, setSelectedEmployee] = useState(employeeId || '');
      const [documentType, setDocumentType] = useState('');
      const [file, setFile] = useState<File | null>(null);
      const [description, setDescription] = useState('');
      const [isUploading, setIsUploading] = useState(false);
      const [error, setError] = useState('');
      const fileInputRef = useRef<HTMLInputElement>(null);

      async function handleUpload() {
        if (!selectedEmployee || !documentType || !file) {
          setError('Please select employee, document type, and file');
          return;
        }

        setError('');
        setIsUploading(true);

        try {
          const formData = new FormData();
          formData.append('file', file);
          formData.append('employeeId', selectedEmployee);
          formData.append('type', documentType);
          if (description) formData.append('description', description);

          const res = await fetch('/api/documents', {
            method: 'POST',
            body: formData,
          });

          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.error || 'Upload failed');
          }

          // Reset form
          setFile(null);
          setDocumentType('');
          setDescription('');
          if (fileInputRef.current) fileInputRef.current.value = '';

          onUploadComplete?.();
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Upload failed');
        } finally {
          setIsUploading(false);
        }
      }

      const documentTypeLabels: Record<string, string> = {
        OFFER_LETTER: 'Offer Letter',
        ID_PROOF: 'ID Proof',
        ADDRESS_PROOF: 'Address Proof',
        EDUCATION_CERT: 'Education Certificate',
        EXPERIENCE_CERT: 'Experience Certificate',
        PAN_CARD: 'PAN Card',
        AADHAAR_CARD: 'Aadhaar Card',
        BANK_PROOF: 'Bank Proof',
        OTHER: 'Other',
      };

      return (
        <Card>
          <CardHeader>
            <CardTitle>Upload Document</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {error && (
              <div className="p-3 text-sm text-red-600 bg-red-50 rounded-md">{error}</div>
            )}

            {!employeeId && employees && (
              <div className="space-y-2">
                <Label>Employee</Label>
                <Select value={selectedEmployee} onValueChange={setSelectedEmployee}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select employee" />
                  </SelectTrigger>
                  <SelectContent>
                    {employees.map((emp) => (
                      <SelectItem key={emp.id} value={emp.id}>
                        {emp.employeeCode} - {emp.firstName} {emp.lastName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            <div className="space-y-2">
              <Label>Document Type</Label>
              <Select value={documentType} onValueChange={setDocumentType}>
                <SelectTrigger>
                  <SelectValue placeholder="Select type" />
                </SelectTrigger>
                <SelectContent>
                  {DOCUMENT_TYPES.map((type) => (
                    <SelectItem key={type} value={type}>
                      {documentTypeLabels[type] || type}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label>File</Label>
              <div className="flex items-center gap-2">
                <Input
                  ref={fileInputRef}
                  type="file"
                  onChange={(e) => setFile(e.target.files?.[0] || null)}
                  accept=".pdf,.jpg,.jpeg,.png,.doc,.docx"
                />
                {file && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      setFile(null);
                      if (fileInputRef.current) fileInputRef.current.value = '';
                    }}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                )}
              </div>
              <p className="text-xs text-gray-500">
                Max 10MB. Allowed: PDF, JPG, PNG, DOC, DOCX
              </p>
            </div>

            <div className="space-y-2">
              <Label>Description (optional)</Label>
              <Input
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Add a description..."
              />
            </div>

            <Button onClick={handleUpload} disabled={isUploading} className="w-full">
              <Upload className="mr-2 h-4 w-4" />
              {isUploading ? 'Uploading...' : 'Upload Document'}
            </Button>
          </CardContent>
        </Card>
      );
    }
    ```

    Create src/app/(dashboard)/documents/page.tsx:
    ```typescript
    'use client';

    import { useState, useEffect } from 'react';
    import { Button } from '@/components/ui/button';
    import { Badge } from '@/components/ui/badge';
    import {
      Table,
      TableBody,
      TableCell,
      TableHead,
      TableHeader,
      TableRow,
    } from '@/components/ui/table';
    import {
      Select,
      SelectContent,
      SelectItem,
      SelectTrigger,
      SelectValue,
    } from '@/components/ui/select';
    import { DocumentUpload } from '@/components/documents/document-upload';
    import { Download, FileText, Trash2 } from 'lucide-react';
    import { format } from 'date-fns';

    interface Document {
      id: string;
      type: string;
      originalName: string;
      fileSize: number;
      uploadedAt: string;
      retentionUntil: string;
      employee: { id: string; firstName: string; lastName: string; employeeCode: string };
    }

    interface Employee {
      id: string;
      firstName: string;
      lastName: string;
      employeeCode: string;
    }

    export default function DocumentsPage() {
      const [documents, setDocuments] = useState<Document[]>([]);
      const [employees, setEmployees] = useState<Employee[]>([]);
      const [selectedEmployee, setSelectedEmployee] = useState('');
      const [isLoading, setIsLoading] = useState(true);

      useEffect(() => {
        fetchEmployees();
        fetchDocuments();
      }, []);

      useEffect(() => {
        fetchDocuments();
      }, [selectedEmployee]);

      async function fetchEmployees() {
        const res = await fetch('/api/employees?limit=100');
        const data = await res.json();
        setEmployees(data.employees || []);
      }

      async function fetchDocuments() {
        setIsLoading(true);
        const params = new URLSearchParams();
        if (selectedEmployee) params.set('employeeId', selectedEmployee);

        const res = await fetch(`/api/documents?${params}`);
        const data = await res.json();
        setDocuments(data);
        setIsLoading(false);
      }

      async function deleteDocument(id: string) {
        if (!confirm('Delete this document?')) return;
        await fetch(`/api/documents/${id}`, { method: 'DELETE' });
        fetchDocuments();
      }

      function formatFileSize(bytes: number): string {
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }

      const typeLabels: Record<string, string> = {
        OFFER_LETTER: 'Offer Letter',
        ID_PROOF: 'ID Proof',
        ADDRESS_PROOF: 'Address Proof',
        EDUCATION_CERT: 'Education',
        EXPERIENCE_CERT: 'Experience',
        PAN_CARD: 'PAN Card',
        AADHAAR_CARD: 'Aadhaar',
        BANK_PROOF: 'Bank Proof',
        OTHER: 'Other',
      };

      return (
        <div className="space-y-6">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Documents</h1>
            <p className="text-gray-600">Manage employee documents (8-year retention)</p>
          </div>

          <div className="grid gap-6 lg:grid-cols-3">
            <div className="lg:col-span-2 space-y-4">
              <div className="flex items-center gap-4">
                <Select value={selectedEmployee} onValueChange={setSelectedEmployee}>
                  <SelectTrigger className="w-64">
                    <SelectValue placeholder="Filter by employee" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="">All Employees</SelectItem>
                    {employees.map((emp) => (
                      <SelectItem key={emp.id} value={emp.id}>
                        {emp.employeeCode} - {emp.firstName} {emp.lastName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="rounded-md border">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Document</TableHead>
                      <TableHead>Employee</TableHead>
                      <TableHead>Type</TableHead>
                      <TableHead>Size</TableHead>
                      <TableHead>Uploaded</TableHead>
                      <TableHead>Retention Until</TableHead>
                      <TableHead></TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {isLoading ? (
                      <TableRow>
                        <TableCell colSpan={7} className="text-center py-8">
                          Loading...
                        </TableCell>
                      </TableRow>
                    ) : documents.length === 0 ? (
                      <TableRow>
                        <TableCell colSpan={7} className="text-center py-8 text-gray-500">
                          No documents found
                        </TableCell>
                      </TableRow>
                    ) : (
                      documents.map((doc) => (
                        <TableRow key={doc.id}>
                          <TableCell className="font-medium">
                            <div className="flex items-center gap-2">
                              <FileText className="h-4 w-4 text-gray-400" />
                              <span className="truncate max-w-[200px]">{doc.originalName}</span>
                            </div>
                          </TableCell>
                          <TableCell>
                            {doc.employee.firstName} {doc.employee.lastName}
                          </TableCell>
                          <TableCell>
                            <Badge variant="outline">{typeLabels[doc.type] || doc.type}</Badge>
                          </TableCell>
                          <TableCell>{formatFileSize(doc.fileSize)}</TableCell>
                          <TableCell>{format(new Date(doc.uploadedAt), 'dd MMM yyyy')}</TableCell>
                          <TableCell>{format(new Date(doc.retentionUntil), 'dd MMM yyyy')}</TableCell>
                          <TableCell>
                            <div className="flex gap-1">
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => window.open(`/api/documents/${doc.id}/download`, '_blank')}
                              >
                                <Download className="h-4 w-4" />
                              </Button>
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => deleteDocument(doc.id)}
                              >
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            </div>
                          </TableCell>
                        </TableRow>
                      ))
                    )}
                  </TableBody>
                </Table>
              </div>
            </div>

            <div>
              <DocumentUpload
                employees={employees}
                onUploadComplete={fetchDocuments}
              />
            </div>
          </div>
        </div>
      );
    }
    ```

    Install date-fns:
    ```bash
    pnpm add date-fns
    ```

    Create src/components/import/keka-import.tsx:
    ```typescript
    'use client';

    import { useState, useRef } from 'react';
    import { Button } from '@/components/ui/button';
    import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
    import { Badge } from '@/components/ui/badge';
    import { Upload, Users, DollarSign, Calendar, CheckCircle, XCircle, AlertCircle } from 'lucide-react';

    interface ImportResult {
      batchId: string;
      totalRecords: number;
      successCount: number;
      errorCount: number;
      errors?: { row: number; field: string; message: string }[];
    }

    interface ImportCardProps {
      title: string;
      description: string;
      icon: React.ReactNode;
      endpoint: string;
      expectedColumns: string[];
    }

    function ImportCard({ title, description, icon, endpoint, expectedColumns }: ImportCardProps) {
      const [file, setFile] = useState<File | null>(null);
      const [isImporting, setIsImporting] = useState(false);
      const [result, setResult] = useState<ImportResult | null>(null);
      const fileInputRef = useRef<HTMLInputElement>(null);

      async function handleImport() {
        if (!file) return;

        setIsImporting(true);
        setResult(null);

        try {
          const formData = new FormData();
          formData.append('file', file);

          const res = await fetch(endpoint, {
            method: 'POST',
            body: formData,
          });

          const data = await res.json();

          if (!res.ok) {
            throw new Error(data.error || 'Import failed');
          }

          setResult(data);
          setFile(null);
          if (fileInputRef.current) fileInputRef.current.value = '';
        } catch (err) {
          setResult({
            batchId: '',
            totalRecords: 0,
            successCount: 0,
            errorCount: 1,
            errors: [{ row: 0, field: 'general', message: err instanceof Error ? err.message : 'Import failed' }],
          });
        } finally {
          setIsImporting(false);
        }
      }

      return (
        <Card>
          <CardHeader>
            <div className="flex items-center gap-3">
              {icon}
              <div>
                <CardTitle className="text-lg">{title}</CardTitle>
                <CardDescription>{description}</CardDescription>
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="text-xs text-gray-500">
              <p className="font-medium mb-1">Expected CSV columns:</p>
              <p className="break-words">{expectedColumns.join(', ')}</p>
            </div>

            <div className="flex items-center gap-2">
              <input
                ref={fileInputRef}
                type="file"
                accept=".csv"
                onChange={(e) => setFile(e.target.files?.[0] || null)}
                className="flex-1 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-medium file:bg-gray-100 file:text-gray-700 hover:file:bg-gray-200"
              />
            </div>

            <Button
              onClick={handleImport}
              disabled={!file || isImporting}
              className="w-full"
            >
              <Upload className="mr-2 h-4 w-4" />
              {isImporting ? 'Importing...' : 'Import CSV'}
            </Button>

            {result && (
              <div className={`p-4 rounded-md ${result.errorCount === 0 ? 'bg-green-50' : result.successCount > 0 ? 'bg-yellow-50' : 'bg-red-50'}`}>
                <div className="flex items-center gap-2 mb-2">
                  {result.errorCount === 0 ? (
                    <CheckCircle className="h-5 w-5 text-green-600" />
                  ) : result.successCount > 0 ? (
                    <AlertCircle className="h-5 w-5 text-yellow-600" />
                  ) : (
                    <XCircle className="h-5 w-5 text-red-600" />
                  )}
                  <span className="font-medium">
                    {result.successCount} of {result.totalRecords} imported
                  </span>
                </div>

                {result.errors && result.errors.length > 0 && (
                  <div className="mt-2 space-y-1 max-h-40 overflow-y-auto">
                    {result.errors.slice(0, 10).map((err, i) => (
                      <div key={i} className="text-xs text-red-700">
                        Row {err.row}: {err.field} - {err.message}
                      </div>
                    ))}
                    {result.errors.length > 10 && (
                      <div className="text-xs text-red-700">
                        ...and {result.errors.length - 10} more errors
                      </div>
                    )}
                  </div>
                )}
              </div>
            )}
          </CardContent>
        </Card>
      );
    }

    export function KekaImport() {
      return (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          <ImportCard
            title="Employee Data"
            description="Import employee profiles from Keka export"
            icon={<Users className="h-8 w-8 text-blue-600" />}
            endpoint="/api/import/employees"
            expectedColumns={[
              'Employee Code', 'First Name', 'Last Name', 'Date of Birth', 'Gender',
              'Personal Email', 'Work Email', 'Phone', 'Date of Joining', 'Department',
              'Designation', 'Reporting Manager Code', 'PAN', 'Bank Account', 'IFSC',
              'Bank Name', 'UAN', 'State'
            ]}
          />

          <ImportCard
            title="Salary History"
            description="Import salary records for Form 16 continuity"
            icon={<DollarSign className="h-8 w-8 text-green-600" />}
            endpoint="/api/import/salary"
            expectedColumns={[
              'Employee Code', 'Month', 'Year', 'Basic', 'HRA', 'Conveyance',
              'Special Allowance', 'Other Allowances', 'Gross', 'PF Employee',
              'PF Employer', 'ESI Employee', 'ESI Employer', 'PT', 'TDS',
              'Other Deductions', 'Net'
            ]}
          />

          <ImportCard
            title="Leave Balances"
            description="Import current leave balances from Keka"
            icon={<Calendar className="h-8 w-8 text-purple-600" />}
            endpoint="/api/import/leave"
            expectedColumns={[
              'Employee Code', 'Leave Type', 'Year', 'Opening', 'Accrued', 'Used', 'Balance'
            ]}
          />
        </div>
      );
    }
    ```

    Create src/app/(dashboard)/import/page.tsx:
    ```typescript
    import { KekaImport } from '@/components/import/keka-import';

    export default function ImportPage() {
      return (
        <div className="space-y-6">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Import Data from Keka</h1>
            <p className="text-gray-600">
              Migrate your employee data, salary history, and leave balances from Keka HR exports
            </p>
          </div>

          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <h3 className="font-medium text-blue-900 mb-2">Import Order</h3>
            <ol className="list-decimal list-inside text-sm text-blue-800 space-y-1">
              <li>First, import <strong>Employee Data</strong> - this creates employee records and auto-creates departments/designations</li>
              <li>Then, import <strong>Salary History</strong> - links to existing employees by Employee Code</li>
              <li>Finally, import <strong>Leave Balances</strong> - links to existing employees by Employee Code</li>
            </ol>
          </div>

          <KekaImport />
        </div>
      );
    }
    ```
  </action>
  <verify>
    1. `pnpm dev` and visit /dashboard/documents
    2. Upload a PDF document for an employee
    3. Document appears in list with 8-year retention date
    4. Download button retrieves the file
    5. Visit /dashboard/import
    6. Create a test CSV with employee data and import
    7. Check that employees were created
  </verify>
  <done>
    Document management UI with upload, list, download, delete.
    Keka import UI with three import cards (employees, salary, leave).
    Import shows success/error counts and error details.
  </done>
</task>

</tasks>

<verification>
1. Document upload saves file to ./uploads/employees/{id}/
2. Document record has retentionUntil = uploadedAt + 8 years
3. Download endpoint serves file with correct headers
4. Keka employee import creates employees with encrypted PII
5. Keka employee import auto-creates departments and designations
6. Keka salary import creates SalaryRecord entries
7. Keka leave import creates LeaveBalance entries
8. All imports track batch, show errors, don't fail entire batch on single error
9. UI: Documents page shows list and upload form
10. UI: Import page shows three import cards with expected columns
</verification>

<success_criteria>
- Document storage with local filesystem (./uploads/)
- 8-year retention date calculated and stored
- Document CRUD with access control
- File download with proper headers
- Keka CSV parsers handle multiple date formats
- Employee import with PII encryption
- Salary history import in paise for precision
- Leave balance import with upsert
- Import batch tracking with error details
- Documents page with filter, upload, download, delete
- Import page with three import types and instructions
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
