---
phase: 02-time-attendance
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/app/api/attendance/sync/route.ts
  - src/app/api/leave-balances/route.ts
  - src/app/api/leave-balances/[employeeId]/route.ts
autonomous: true

must_haves:
  truths:
    - "System syncs approved leave to attendance (marks leave days)"
    - "System syncs unapproved absence as LOP to payroll"
    - "Employee can view current leave balances"
  artifacts:
    - path: "src/app/api/attendance/sync/route.ts"
      provides: "Leave to attendance sync"
      exports: ["POST"]
    - path: "src/app/api/leave-balances/route.ts"
      provides: "Leave balance API"
      exports: ["GET"]
    - path: "src/app/api/leave-balances/[employeeId]/route.ts"
      provides: "Employee leave balance detail"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/attendance/sync/route.ts"
      to: "prisma.attendance"
      via: "upsert for leave days"
      pattern: "prisma\\.attendance\\.upsert"
    - from: "src/app/api/leave-balances/route.ts"
      to: "prisma.leaveBalance"
      via: "database query"
      pattern: "prisma\\.leaveBalance\\.findMany"
---

<objective>
Create leave-to-attendance sync and leave balance viewing APIs.

Purpose: Ensure approved leave automatically marks attendance calendar and unapproved absences are tracked as LOP for payroll. Employees need visibility into their leave balances.
Output: Attendance sync API, leave balance APIs
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@prisma/schema.prisma
@src/app/api/attendance/route.ts
@src/app/api/leave-requests/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create leave-to-attendance sync API</name>
  <files>src/app/api/attendance/sync/route.ts</files>
  <action>
Create sync API at src/app/api/attendance/sync/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';

// Sync approved leave requests to attendance records
// This should be run:
// 1. When a leave request is approved (from leave-requests API)
// 2. As a daily job to catch any missed syncs
// 3. Before payroll processing to ensure attendance is complete

export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { month, year, employeeId } = body;

    if (!month || !year) {
      return NextResponse.json({ error: 'Month and year are required' }, { status: 400 });
    }

    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0); // Last day of month

    // Build query for approved leave requests in the period
    const leaveWhere: any = {
      status: 'APPROVED',
      OR: [
        // Leave starts in this month
        { start_date: { gte: startDate, lte: endDate } },
        // Leave ends in this month
        { end_date: { gte: startDate, lte: endDate } },
        // Leave spans this month
        { start_date: { lte: startDate }, end_date: { gte: endDate } }
      ]
    };

    if (employeeId) {
      leaveWhere.employee_id = employeeId;
    }

    const approvedLeaves = await prisma.leaveRequest.findMany({
      where: leaveWhere,
      include: {
        leave_type: { select: { is_paid: true, code: true } }
      }
    });

    let synced = 0;
    let errors: string[] = [];

    for (const leave of approvedLeaves) {
      // Iterate through each day of the leave
      const leaveStart = new Date(Math.max(startDate.getTime(), new Date(leave.start_date).getTime()));
      const leaveEnd = new Date(Math.min(endDate.getTime(), new Date(leave.end_date).getTime()));

      const current = new Date(leaveStart);
      while (current <= leaveEnd) {
        const dayOfWeek = current.getDay();

        // Skip weekends
        if (dayOfWeek !== 0 && dayOfWeek !== 6) {
          try {
            const dateOnly = new Date(current.getFullYear(), current.getMonth(), current.getDate());

            // Determine if this is half-day leave
            let status: 'ON_LEAVE' | 'HALF_DAY' = 'ON_LEAVE';
            let workMinutes = 0;

            if (leave.is_half_day) {
              status = 'HALF_DAY';
              workMinutes = 240; // 4 hours for half day
            }

            await prisma.attendance.upsert({
              where: {
                employee_id_date: {
                  employee_id: leave.employee_id,
                  date: dateOnly
                }
              },
              create: {
                employee_id: leave.employee_id,
                date: dateOnly,
                status,
                work_minutes: workMinutes,
                source: 'MANUAL',
                remarks: `${leave.leave_type.code} - ${leave.reason}`,
                created_by: session.user.id,
                updated_by: session.user.id,
              },
              update: {
                status,
                work_minutes: leave.is_half_day ? workMinutes : 0,
                remarks: `${leave.leave_type.code} - ${leave.reason}`,
                updated_by: session.user.id,
              }
            });

            synced++;
          } catch (err) {
            errors.push(`Failed to sync ${current.toISOString().split('T')[0]} for employee ${leave.employee_id}`);
          }
        }

        current.setDate(current.getDate() + 1);
      }
    }

    // Now identify days with no attendance record (potential LOP)
    // Get all active employees
    const employees = employeeId
      ? [{ id: employeeId }]
      : await prisma.employee.findMany({
          where: { employment_status: 'ACTIVE' },
          select: { id: true }
        });

    let lopDays: { employeeId: string; date: Date }[] = [];

    for (const emp of employees) {
      const current = new Date(startDate);
      while (current <= endDate) {
        const dayOfWeek = current.getDay();

        // Skip weekends
        if (dayOfWeek !== 0 && dayOfWeek !== 6) {
          const dateOnly = new Date(current.getFullYear(), current.getMonth(), current.getDate());

          // Check if attendance exists
          const attendance = await prisma.attendance.findUnique({
            where: {
              employee_id_date: {
                employee_id: emp.id,
                date: dateOnly
              }
            }
          });

          if (!attendance) {
            // No record = absent without leave = LOP
            lopDays.push({ employeeId: emp.id, date: dateOnly });

            // Create LOP attendance record
            await prisma.attendance.create({
              data: {
                employee_id: emp.id,
                date: dateOnly,
                status: 'ABSENT',
                source: 'MANUAL',
                remarks: 'Absent - marked as LOP',
                created_by: session.user.id,
                updated_by: session.user.id,
              }
            });
          }
        }

        current.setDate(current.getDate() + 1);
      }
    }

    return NextResponse.json({
      message: 'Sync completed',
      synced,
      lopDaysMarked: lopDays.length,
      errors: errors.length > 0 ? errors : undefined
    });
  } catch (error) {
    console.error('Attendance sync error:', error);
    return NextResponse.json({ error: 'Failed to sync attendance' }, { status: 500 });
  }
}
```

This API:
1. Finds all approved leave requests that overlap with the given month
2. Creates/updates attendance records for each leave day
3. Identifies days with no attendance (no check-in, no leave) and marks as ABSENT (LOP)
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation.
Test manually:
- POST /api/attendance/sync with { month: 2, year: 2026 } syncs approved leaves
- Missing days without attendance are marked as ABSENT
  </verify>
  <done>Attendance sync API marks leave days and identifies LOP days</done>
</task>

<task type="auto">
  <name>Task 2: Create leave balance APIs</name>
  <files>
    src/app/api/leave-balances/route.ts
    src/app/api/leave-balances/[employeeId]/route.ts
  </files>
  <action>
Create leave balance list API at src/app/api/leave-balances/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';

export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const year = parseInt(searchParams.get('year') || String(new Date().getFullYear()));
    const employeeId = searchParams.get('employeeId');

    // For employees, only show their own balance
    const targetEmployeeId = session.user.role === 'EMPLOYEE'
      ? session.user.employeeId
      : (employeeId || session.user.employeeId);

    if (!targetEmployeeId) {
      return NextResponse.json({ error: 'Employee ID required' }, { status: 400 });
    }

    // Get all leave types
    const leaveTypes = await prisma.leaveType.findMany({
      where: { is_active: true },
      orderBy: { name: 'asc' }
    });

    // Get existing balances
    const existingBalances = await prisma.leaveBalance.findMany({
      where: {
        employee_id: targetEmployeeId,
        year,
      }
    });

    // Get pending leave requests to show committed but not yet used
    const pendingLeaves = await prisma.leaveRequest.groupBy({
      by: ['leave_type_id'],
      where: {
        employee_id: targetEmployeeId,
        status: 'PENDING',
        start_date: { gte: new Date(year, 0, 1) },
        end_date: { lte: new Date(year, 11, 31) },
      },
      _sum: { days_count: true }
    });

    const pendingByType = new Map(pendingLeaves.map(p => [p.leave_type_id, p._sum.days_count || 0]));

    // Build combined balance view
    const balances = leaveTypes.map(lt => {
      const existing = existingBalances.find(b => b.leave_type === lt.code);
      const pending = pendingByType.get(lt.id) || 0;

      return {
        leaveTypeId: lt.id,
        leaveTypeName: lt.name,
        leaveTypeCode: lt.code,
        isPaid: lt.is_paid,
        year,
        opening: existing?.opening ?? lt.annual_quota,
        accrued: existing?.accrued ?? 0,
        used: existing?.used ?? 0,
        pending,
        balance: existing?.balance ?? lt.annual_quota,
        available: (existing?.balance ?? lt.annual_quota) - pending,
      };
    });

    return NextResponse.json({
      employeeId: targetEmployeeId,
      year,
      balances,
    });
  } catch (error) {
    console.error('Leave balances error:', error);
    return NextResponse.json({ error: 'Failed to fetch leave balances' }, { status: 500 });
  }
}

// Admin can initialize/reset leave balances for new year
export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { year, employeeId, carryForward = false } = body;

    if (!year) {
      return NextResponse.json({ error: 'Year is required' }, { status: 400 });
    }

    // Get all active leave types
    const leaveTypes = await prisma.leaveType.findMany({
      where: { is_active: true }
    });

    // Get employees to initialize
    const employees = employeeId
      ? [{ id: employeeId }]
      : await prisma.employee.findMany({
          where: { employment_status: 'ACTIVE' },
          select: { id: true }
        });

    let created = 0;

    for (const emp of employees) {
      for (const lt of leaveTypes) {
        let opening = lt.annual_quota;

        // Carry forward from previous year if requested
        if (carryForward) {
          const prevBalance = await prisma.leaveBalance.findFirst({
            where: {
              employee_id: emp.id,
              leave_type: lt.code,
              year: year - 1,
            }
          });

          if (prevBalance) {
            const carryOver = Math.min(prevBalance.balance, lt.max_carry_forward);
            opening = lt.annual_quota + carryOver;
          }
        }

        await prisma.leaveBalance.upsert({
          where: {
            employee_id_leave_type_year: {
              employee_id: emp.id,
              leave_type: lt.code,
              year,
            }
          },
          create: {
            employee_id: emp.id,
            leave_type: lt.code,
            year,
            opening,
            accrued: 0,
            used: 0,
            balance: opening,
            created_by: session.user.id,
            updated_by: session.user.id,
          },
          update: {
            // Only update opening if carry forward changed it
            opening: carryForward ? opening : undefined,
            balance: carryForward ? opening : undefined,
            updated_by: session.user.id,
          }
        });

        created++;
      }
    }

    return NextResponse.json({
      message: 'Leave balances initialized',
      employeesProcessed: employees.length,
      balancesCreated: created,
    });
  } catch (error) {
    console.error('Leave balance init error:', error);
    return NextResponse.json({ error: 'Failed to initialize leave balances' }, { status: 500 });
  }
}
```

Create employee leave balance detail API at src/app/api/leave-balances/[employeeId]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ employeeId: string }> }
) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { employeeId } = await params;

  // Check access
  if (session.user.role === 'EMPLOYEE' && session.user.employeeId !== employeeId) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const year = parseInt(searchParams.get('year') || String(new Date().getFullYear()));

    // Get employee info
    const employee = await prisma.employee.findUnique({
      where: { id: employeeId },
      select: { id: true, first_name: true, last_name: true, employee_code: true }
    });

    if (!employee) {
      return NextResponse.json({ error: 'Employee not found' }, { status: 404 });
    }

    // Get all leave types
    const leaveTypes = await prisma.leaveType.findMany({
      where: { is_active: true },
      orderBy: { name: 'asc' }
    });

    // Get existing balances
    const existingBalances = await prisma.leaveBalance.findMany({
      where: { employee_id: employeeId, year }
    });

    // Get pending and approved leave counts
    const leaveStats = await prisma.leaveRequest.groupBy({
      by: ['leave_type_id', 'status'],
      where: {
        employee_id: employeeId,
        status: { in: ['PENDING', 'APPROVED'] },
        start_date: { gte: new Date(year, 0, 1) },
        end_date: { lte: new Date(year, 11, 31) },
      },
      _sum: { days_count: true }
    });

    // Get leave history for this year
    const leaveHistory = await prisma.leaveRequest.findMany({
      where: {
        employee_id: employeeId,
        start_date: { gte: new Date(year, 0, 1) },
        end_date: { lte: new Date(year, 11, 31) },
      },
      include: {
        leave_type: { select: { name: true, code: true } }
      },
      orderBy: { start_date: 'desc' },
      take: 10
    });

    // Build detailed balance view
    const balances = leaveTypes.map(lt => {
      const existing = existingBalances.find(b => b.leave_type === lt.code);

      const pendingStat = leaveStats.find(s => s.leave_type_id === lt.id && s.status === 'PENDING');
      const approvedStat = leaveStats.find(s => s.leave_type_id === lt.id && s.status === 'APPROVED');

      const pending = pendingStat?._sum.days_count || 0;
      const approvedThisYear = approvedStat?._sum.days_count || 0;

      return {
        leaveTypeId: lt.id,
        leaveTypeName: lt.name,
        leaveTypeCode: lt.code,
        isPaid: lt.is_paid,
        requiresApproval: lt.requires_approval,
        minDaysNotice: lt.min_days_notice,
        year,
        opening: existing?.opening ?? lt.annual_quota,
        accrued: existing?.accrued ?? 0,
        usedTotal: existing?.used ?? 0,
        usedThisYear: approvedThisYear,
        pending,
        balance: existing?.balance ?? lt.annual_quota,
        available: (existing?.balance ?? lt.annual_quota) - pending,
      };
    });

    return NextResponse.json({
      employee,
      year,
      balances,
      recentRequests: leaveHistory,
    });
  } catch (error) {
    console.error('Leave balance detail error:', error);
    return NextResponse.json({ error: 'Failed to fetch leave balance' }, { status: 500 });
  }
}

// Admin can manually adjust leave balance
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ employeeId: string }> }
) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { employeeId } = await params;

  try {
    const body = await request.json();
    const { leaveTypeCode, year, adjustment, reason } = body;

    if (!leaveTypeCode || !year || adjustment === undefined) {
      return NextResponse.json({ error: 'leaveTypeCode, year, and adjustment are required' }, { status: 400 });
    }

    const existing = await prisma.leaveBalance.findFirst({
      where: {
        employee_id: employeeId,
        leave_type: leaveTypeCode,
        year,
      }
    });

    if (!existing) {
      return NextResponse.json({ error: 'Leave balance record not found' }, { status: 404 });
    }

    const newBalance = existing.balance + adjustment;

    if (newBalance < 0) {
      return NextResponse.json({ error: 'Adjustment would result in negative balance' }, { status: 400 });
    }

    const updated = await prisma.leaveBalance.update({
      where: { id: existing.id },
      data: {
        accrued: adjustment > 0 ? existing.accrued + adjustment : existing.accrued,
        used: adjustment < 0 ? existing.used - adjustment : existing.used,
        balance: newBalance,
        updated_by: session.user.id,
      }
    });

    return NextResponse.json({
      message: 'Leave balance adjusted',
      previousBalance: existing.balance,
      adjustment,
      newBalance,
      reason,
    });
  } catch (error) {
    console.error('Leave balance adjust error:', error);
    return NextResponse.json({ error: 'Failed to adjust leave balance' }, { status: 500 });
  }
}
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation.
Test manually:
- GET /api/leave-balances returns current user's balance
- GET /api/leave-balances?employeeId=xxx returns specific employee (admin only)
- POST /api/leave-balances initializes balances for new year
- PATCH /api/leave-balances/[employeeId] adjusts balance
  </verify>
  <done>Leave balance APIs allow viewing, initialization, and manual adjustment</done>
</task>

</tasks>

<verification>
1. Run `pnpm tsc --noEmit` - no TypeScript errors
2. Run `pnpm build` - build completes
3. Manual API tests:
   - Sync creates attendance records for approved leave days
   - Days without attendance marked as ABSENT
   - Leave balance shows opening, used, pending, available
   - Admin can initialize balances for new year with carry forward
</verification>

<success_criteria>
- POST /api/attendance/sync marks approved leave days in attendance
- Unapproved absence days marked as ABSENT (LOP)
- GET /api/leave-balances returns employee's balance by leave type
- Balance shows: opening, accrued, used, pending, available
- Admin can initialize balances for new year with optional carry forward
- Admin can manually adjust balances with audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/02-time-attendance/02-03-SUMMARY.md`
</output>
