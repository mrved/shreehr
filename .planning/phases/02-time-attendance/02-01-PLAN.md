---
phase: 02-time-attendance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/validations/attendance.ts
  - src/app/api/attendance/route.ts
  - src/app/api/attendance/[id]/route.ts
  - src/app/api/attendance/check-in/route.ts
  - src/app/api/attendance/check-out/route.ts
autonomous: true

must_haves:
  truths:
    - "Employee can check-in via web interface"
    - "Employee can check-out via web interface"
    - "System calculates daily work hours from check-in/out times"
    - "System marks attendance status (Present, Absent, Half-day)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Attendance and AttendanceLock models"
      contains: "model Attendance"
    - path: "src/app/api/attendance/check-in/route.ts"
      provides: "Check-in endpoint"
      exports: ["POST"]
    - path: "src/app/api/attendance/check-out/route.ts"
      provides: "Check-out endpoint"
      exports: ["POST"]
    - path: "src/lib/validations/attendance.ts"
      provides: "Attendance Zod schemas"
      exports: ["attendanceSchema"]
  key_links:
    - from: "src/app/api/attendance/check-in/route.ts"
      to: "prisma.attendance"
      via: "database create"
      pattern: "prisma\\.attendance\\.create"
    - from: "src/app/api/attendance/check-out/route.ts"
      to: "prisma.attendance"
      via: "database update"
      pattern: "prisma\\.attendance\\.update"
---

<objective>
Create the attendance tracking foundation with Prisma models and check-in/check-out API endpoints.

Purpose: Enable employees to record daily attendance with automatic work hours calculation and status marking. This feeds into payroll for LOP calculation.
Output: Attendance model, check-in/check-out APIs, work hours calculation logic
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@prisma/schema.prisma
@src/app/api/employees/route.ts
@src/lib/validations/employee.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Attendance model to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add Attendance model with the following structure:

```prisma
model Attendance {
  id              String   @id @default(cuid())
  employee_id     String
  employee        Employee @relation(fields: [employee_id], references: [id], onDelete: Cascade)

  date            DateTime @db.Date  // The attendance date
  check_in        DateTime?          // Check-in timestamp
  check_out       DateTime?          // Check-out timestamp
  work_minutes    Int      @default(0)  // Calculated work duration in minutes

  status          AttendanceStatus @default(ABSENT)
  source          AttendanceSource @default(WEB)

  remarks         String?
  is_regularized  Boolean  @default(false)  // If manually corrected
  regularized_by  String?
  regularized_at  DateTime?

  // Audit fields
  created_at      DateTime @default(now())
  created_by      String?
  creator         User?    @relation("AttendanceCreatedBy", fields: [created_by], references: [id])
  updated_at      DateTime @updatedAt
  updated_by      String?
  updater         User?    @relation("AttendanceUpdatedBy", fields: [updated_by], references: [id])

  @@unique([employee_id, date])
  @@index([date])
  @@index([status])
  @@map("attendances")
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  HALF_DAY
  ON_LEAVE
  HOLIDAY
  WEEKEND
}

enum AttendanceSource {
  WEB
  MOBILE
  BIOMETRIC
  IMPORT
  MANUAL
}
```

Also add AttendanceLock model for payroll locking:

```prisma
model AttendanceLock {
  id          String   @id @default(cuid())
  month       Int      // 1-12
  year        Int
  locked_at   DateTime @default(now())
  locked_by   String
  locker      User     @relation("AttendanceLockLockedBy", fields: [locked_by], references: [id])

  // Allow corrections with approval
  unlock_requested_by  String?
  unlock_requested_at  DateTime?
  unlock_reason        String?
  unlock_approved_by   String?
  unlock_approved_at   DateTime?

  @@unique([month, year])
  @@map("attendance_locks")
}
```

Add the necessary relations to User model:
- created_attendances Attendance[] @relation("AttendanceCreatedBy")
- updated_attendances Attendance[] @relation("AttendanceUpdatedBy")
- locked_attendance_periods AttendanceLock[] @relation("AttendanceLockLockedBy")

Add relation to Employee model:
- attendances Attendance[]

Run `pnpm db:push` to apply schema changes.
  </action>
  <verify>
Run `pnpm db:push` succeeds without errors.
Run `pnpm prisma generate` succeeds.
Check prisma/schema.prisma contains model Attendance with all fields.
  </verify>
  <done>Attendance and AttendanceLock models exist in schema, database migrated successfully</done>
</task>

<task type="auto">
  <name>Task 2: Create attendance validation schemas and check-in/check-out APIs</name>
  <files>
    src/lib/validations/attendance.ts
    src/app/api/attendance/check-in/route.ts
    src/app/api/attendance/check-out/route.ts
  </files>
  <action>
Create validation schemas in src/lib/validations/attendance.ts:

```typescript
import { z } from 'zod';

export const checkInSchema = z.object({
  remarks: z.string().max(500).optional(),
});

export const checkOutSchema = z.object({
  remarks: z.string().max(500).optional(),
});

export const attendanceQuerySchema = z.object({
  employeeId: z.string().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  status: z.enum(['PRESENT', 'ABSENT', 'HALF_DAY', 'ON_LEAVE', 'HOLIDAY', 'WEEKEND']).optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(100).default(20),
});

export const regularizeSchema = z.object({
  checkIn: z.string().datetime(),
  checkOut: z.string().datetime().optional(),
  remarks: z.string().max(500),
});

// Helper function to calculate attendance status based on work hours
export function calculateAttendanceStatus(workMinutes: number): 'PRESENT' | 'HALF_DAY' | 'ABSENT' {
  // Full day: >= 7.5 hours (450 minutes)
  // Half day: >= 4 hours (240 minutes) and < 7.5 hours
  // Absent: < 4 hours
  if (workMinutes >= 450) return 'PRESENT';
  if (workMinutes >= 240) return 'HALF_DAY';
  return 'ABSENT';
}
```

Create check-in API at src/app/api/attendance/check-in/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { checkInSchema } from '@/lib/validations/attendance';
import { ZodError } from 'zod';

export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !session.user.employeeId) {
    return NextResponse.json({ error: 'Unauthorized or no employee profile' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const validated = checkInSchema.parse(body);

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // Check if attendance is locked for this month
    const lock = await prisma.attendanceLock.findUnique({
      where: { month_year: { month: today.getMonth() + 1, year: today.getFullYear() } }
    });

    if (lock && !lock.unlock_approved_at) {
      return NextResponse.json({ error: 'Attendance is locked for this period' }, { status: 400 });
    }

    // Check for existing attendance record for today
    const existing = await prisma.attendance.findUnique({
      where: { employee_id_date: { employee_id: session.user.employeeId, date: today } }
    });

    if (existing?.check_in) {
      return NextResponse.json({ error: 'Already checked in for today' }, { status: 400 });
    }

    // Create or update attendance record
    const attendance = await prisma.attendance.upsert({
      where: { employee_id_date: { employee_id: session.user.employeeId, date: today } },
      create: {
        employee_id: session.user.employeeId,
        date: today,
        check_in: now,
        status: 'PRESENT',
        source: 'WEB',
        remarks: validated.remarks,
        created_by: session.user.id,
        updated_by: session.user.id,
      },
      update: {
        check_in: now,
        status: 'PRESENT',
        remarks: validated.remarks,
        updated_by: session.user.id,
      },
    });

    return NextResponse.json(attendance, { status: 201 });
  } catch (error) {
    console.error('Check-in error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to check in' }, { status: 500 });
  }
}
```

Create check-out API at src/app/api/attendance/check-out/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { checkOutSchema, calculateAttendanceStatus } from '@/lib/validations/attendance';
import { ZodError } from 'zod';

export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !session.user.employeeId) {
    return NextResponse.json({ error: 'Unauthorized or no employee profile' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const validated = checkOutSchema.parse(body);

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // Check if attendance is locked
    const lock = await prisma.attendanceLock.findUnique({
      where: { month_year: { month: today.getMonth() + 1, year: today.getFullYear() } }
    });

    if (lock && !lock.unlock_approved_at) {
      return NextResponse.json({ error: 'Attendance is locked for this period' }, { status: 400 });
    }

    // Find today's attendance record
    const existing = await prisma.attendance.findUnique({
      where: { employee_id_date: { employee_id: session.user.employeeId, date: today } }
    });

    if (!existing) {
      return NextResponse.json({ error: 'No check-in record found for today' }, { status: 400 });
    }

    if (!existing.check_in) {
      return NextResponse.json({ error: 'Cannot check out without checking in first' }, { status: 400 });
    }

    if (existing.check_out) {
      return NextResponse.json({ error: 'Already checked out for today' }, { status: 400 });
    }

    // Calculate work minutes
    const checkInTime = new Date(existing.check_in);
    const workMinutes = Math.floor((now.getTime() - checkInTime.getTime()) / (1000 * 60));
    const status = calculateAttendanceStatus(workMinutes);

    // Update attendance record
    const attendance = await prisma.attendance.update({
      where: { id: existing.id },
      data: {
        check_out: now,
        work_minutes: workMinutes,
        status,
        remarks: validated.remarks ? `${existing.remarks || ''}\n${validated.remarks}`.trim() : existing.remarks,
        updated_by: session.user.id,
      },
    });

    return NextResponse.json(attendance);
  } catch (error) {
    console.error('Check-out error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to check out' }, { status: 500 });
  }
}
```

NOTE: The compound unique constraint uses Prisma's convention for @@unique([employee_id, date]) which generates a where clause key of employee_id_date (fields joined with underscore).
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation passes.
Test manually:
- POST /api/attendance/check-in with empty body should create attendance record
- POST /api/attendance/check-out should update with work_minutes calculated
  </verify>
  <done>Check-in creates attendance record, check-out calculates work_minutes and sets status based on hours worked</done>
</task>

<task type="auto">
  <name>Task 3: Create attendance list and detail APIs</name>
  <files>
    src/app/api/attendance/route.ts
    src/app/api/attendance/[id]/route.ts
  </files>
  <action>
Create attendance list API at src/app/api/attendance/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { attendanceQuerySchema } from '@/lib/validations/attendance';

export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const params = attendanceQuerySchema.parse({
      employeeId: searchParams.get('employeeId'),
      startDate: searchParams.get('startDate'),
      endDate: searchParams.get('endDate'),
      status: searchParams.get('status'),
      page: searchParams.get('page'),
      limit: searchParams.get('limit'),
    });

    const where: any = {};

    // Role-based access control
    if (session.user.role === 'EMPLOYEE') {
      // Employees can only see their own attendance
      where.employee_id = session.user.employeeId;
    } else if (session.user.role === 'PAYROLL_MANAGER') {
      // Payroll managers can see team attendance (direct reports)
      if (session.user.employeeId) {
        const managedEmployees = await prisma.employee.findMany({
          where: { reporting_manager_id: session.user.employeeId },
          select: { id: true }
        });
        const managedIds = managedEmployees.map(e => e.id);
        managedIds.push(session.user.employeeId); // Include self
        where.employee_id = { in: managedIds };
      }
    } else if (params.employeeId) {
      // Admin/HR can filter by specific employee
      where.employee_id = params.employeeId;
    }

    if (params.startDate) {
      where.date = { ...where.date, gte: new Date(params.startDate) };
    }

    if (params.endDate) {
      where.date = { ...where.date, lte: new Date(params.endDate) };
    }

    if (params.status) {
      where.status = params.status;
    }

    const [attendances, total] = await Promise.all([
      prisma.attendance.findMany({
        where,
        skip: (params.page - 1) * params.limit,
        take: params.limit,
        orderBy: { date: 'desc' },
        include: {
          employee: {
            select: { id: true, first_name: true, last_name: true, employee_code: true }
          }
        }
      }),
      prisma.attendance.count({ where })
    ]);

    return NextResponse.json({
      attendances,
      pagination: {
        page: params.page,
        limit: params.limit,
        total,
        totalPages: Math.ceil(total / params.limit),
      }
    });
  } catch (error) {
    console.error('Attendance list error:', error);
    return NextResponse.json({ error: 'Failed to fetch attendance' }, { status: 500 });
  }
}

// Get today's attendance status for current employee
export async function HEAD(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !session.user.employeeId) {
    return new NextResponse(null, { status: 401 });
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const attendance = await prisma.attendance.findUnique({
    where: { employee_id_date: { employee_id: session.user.employeeId, date: today } }
  });

  // Return status in custom headers for quick check
  const headers = new Headers();
  headers.set('X-Checked-In', attendance?.check_in ? 'true' : 'false');
  headers.set('X-Checked-Out', attendance?.check_out ? 'true' : 'false');
  headers.set('X-Status', attendance?.status || 'NOT_RECORDED');

  return new NextResponse(null, { status: 200, headers });
}
```

Create attendance detail API at src/app/api/attendance/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { regularizeSchema, calculateAttendanceStatus } from '@/lib/validations/attendance';
import { ZodError } from 'zod';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const attendance = await prisma.attendance.findUnique({
      where: { id },
      include: {
        employee: {
          select: { id: true, first_name: true, last_name: true, employee_code: true }
        }
      }
    });

    if (!attendance) {
      return NextResponse.json({ error: 'Attendance record not found' }, { status: 404 });
    }

    // Check access: employee can only see own, managers can see reports
    if (session.user.role === 'EMPLOYEE' && attendance.employee_id !== session.user.employeeId) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    return NextResponse.json(attendance);
  } catch (error) {
    console.error('Attendance get error:', error);
    return NextResponse.json({ error: 'Failed to fetch attendance' }, { status: 500 });
  }
}

// Regularize attendance (manual correction by admin/HR)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const body = await request.json();
    const validated = regularizeSchema.parse(body);

    const attendance = await prisma.attendance.findUnique({ where: { id } });

    if (!attendance) {
      return NextResponse.json({ error: 'Attendance record not found' }, { status: 404 });
    }

    // Check if attendance is locked
    const attendanceDate = new Date(attendance.date);
    const lock = await prisma.attendanceLock.findUnique({
      where: { month_year: { month: attendanceDate.getMonth() + 1, year: attendanceDate.getFullYear() } }
    });

    if (lock && !lock.unlock_approved_at) {
      return NextResponse.json({ error: 'Attendance is locked for this period' }, { status: 400 });
    }

    const checkIn = new Date(validated.checkIn);
    const checkOut = validated.checkOut ? new Date(validated.checkOut) : null;

    let workMinutes = 0;
    let status: 'PRESENT' | 'HALF_DAY' | 'ABSENT' = 'ABSENT';

    if (checkOut) {
      workMinutes = Math.floor((checkOut.getTime() - checkIn.getTime()) / (1000 * 60));
      status = calculateAttendanceStatus(workMinutes);
    }

    const updated = await prisma.attendance.update({
      where: { id },
      data: {
        check_in: checkIn,
        check_out: checkOut,
        work_minutes: workMinutes,
        status,
        remarks: validated.remarks,
        is_regularized: true,
        regularized_by: session.user.id,
        regularized_at: new Date(),
        updated_by: session.user.id,
      }
    });

    return NextResponse.json(updated);
  } catch (error) {
    console.error('Attendance regularize error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to regularize attendance' }, { status: 500 });
  }
}
```

NOTE: Next.js 15 uses async params in dynamic routes. Access params with `const { id } = await params;`
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation.
Test manually:
- GET /api/attendance returns list with pagination
- GET /api/attendance?employeeId=xxx filters by employee
- PATCH /api/attendance/[id] with checkIn/checkOut updates record as regularized
  </verify>
  <done>Attendance list API returns paginated records with RBAC, detail API allows regularization by admin/HR</done>
</task>

</tasks>

<verification>
1. Run `pnpm db:push` - schema migrates successfully
2. Run `pnpm tsc --noEmit` - no TypeScript errors
3. Run `pnpm build` - build completes
4. Manual API tests:
   - Check-in creates record with status PRESENT
   - Check-out calculates work_minutes and updates status
   - List API respects role-based filtering
   - Regularization marks is_regularized=true
</verification>

<success_criteria>
- Attendance model exists in database with all fields
- Employee can check-in (creates attendance record for today)
- Employee can check-out (calculates work hours)
- Work hours determine status: >=7.5h = PRESENT, >=4h = HALF_DAY, <4h = ABSENT
- Admin/HR can view all attendance, managers see team, employees see self
- Admin/HR can regularize (manually correct) attendance with audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/02-time-attendance/02-01-SUMMARY.md`
</output>
