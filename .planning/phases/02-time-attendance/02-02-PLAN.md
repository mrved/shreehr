---
phase: 02-time-attendance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/validations/leave.ts
  - src/app/api/leave-types/route.ts
  - src/app/api/leave-types/[id]/route.ts
  - src/app/api/leave-requests/route.ts
  - src/app/api/leave-requests/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin can configure leave types (Casual, Sick, Earned/Privilege)"
    - "Admin can set annual leave quota per leave type"
    - "Employee can view current leave balances"
    - "Employee can apply for leave specifying type and dates"
    - "System validates leave application against available balance"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "LeaveType and LeaveRequest models"
      contains: "model LeaveType"
    - path: "src/app/api/leave-types/route.ts"
      provides: "Leave type CRUD"
      exports: ["GET", "POST"]
    - path: "src/app/api/leave-requests/route.ts"
      provides: "Leave request submission"
      exports: ["GET", "POST"]
    - path: "src/lib/validations/leave.ts"
      provides: "Leave Zod schemas"
      exports: ["leaveTypeSchema", "leaveRequestSchema"]
  key_links:
    - from: "src/app/api/leave-requests/route.ts"
      to: "prisma.leaveBalance"
      via: "balance check"
      pattern: "prisma\\.leaveBalance\\.findFirst"
    - from: "src/app/api/leave-requests/route.ts"
      to: "prisma.leaveRequest"
      via: "database create"
      pattern: "prisma\\.leaveRequest\\.create"
---

<objective>
Create leave type configuration and leave request APIs with balance validation.

Purpose: Enable admin to configure leave policies (types and quotas) and employees to apply for leave with automatic balance checking. This integrates with existing LeaveBalance model from Keka import.
Output: LeaveType model, LeaveRequest model, leave type CRUD API, leave request API with validation
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@prisma/schema.prisma
@src/app/api/employees/route.ts
@src/lib/validations/employee.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LeaveType and LeaveRequest models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add LeaveType model for configuring leave policies:

```prisma
model LeaveType {
  id                String   @id @default(cuid())
  name              String   @unique  // e.g., "Casual Leave", "Sick Leave"
  code              String   @unique  // e.g., "CL", "SL", "EL"
  description       String?

  annual_quota      Float    @default(0)  // Default annual entitlement (can be fractional for half-days)
  max_carry_forward Float    @default(0)  // Max days that can be carried to next year
  is_paid           Boolean  @default(true)  // Paid leave or LOP
  requires_approval Boolean  @default(true)
  min_days_notice   Int      @default(0)  // Advance notice required

  is_active         Boolean  @default(true)

  // Audit fields
  created_at        DateTime @default(now())
  created_by        String?
  creator           User?    @relation("LeaveTypeCreatedBy", fields: [created_by], references: [id])
  updated_at        DateTime @updatedAt
  updated_by        String?
  updater           User?    @relation("LeaveTypeUpdatedBy", fields: [updated_by], references: [id])

  // Relations
  leave_requests    LeaveRequest[]

  @@map("leave_types")
}
```

Add LeaveRequest model for tracking leave applications:

```prisma
model LeaveRequest {
  id              String   @id @default(cuid())
  employee_id     String
  employee        Employee @relation(fields: [employee_id], references: [id], onDelete: Cascade)
  leave_type_id   String
  leave_type      LeaveType @relation(fields: [leave_type_id], references: [id])

  start_date      DateTime @db.Date
  end_date        DateTime @db.Date
  days_count      Float    // Calculated from dates (supports half-days)
  is_half_day     Boolean  @default(false)
  half_day_period String?  // "FIRST_HALF" or "SECOND_HALF"

  reason          String
  status          LeaveRequestStatus @default(PENDING)

  // Approval tracking
  approved_by     String?
  approver        User?    @relation("LeaveRequestApprovedBy", fields: [approved_by], references: [id])
  approved_at     DateTime?
  rejection_reason String?

  // Cancellation
  cancelled_at    DateTime?
  cancellation_reason String?

  // Audit fields
  created_at      DateTime @default(now())
  created_by      String?
  creator         User?    @relation("LeaveRequestCreatedBy", fields: [created_by], references: [id])
  updated_at      DateTime @updatedAt
  updated_by      String?
  updater         User?    @relation("LeaveRequestUpdatedBy", fields: [updated_by], references: [id])

  @@index([employee_id, status])
  @@index([start_date, end_date])
  @@map("leave_requests")
}

enum LeaveRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}
```

Add necessary relations to User model:
- created_leave_types LeaveType[] @relation("LeaveTypeCreatedBy")
- updated_leave_types LeaveType[] @relation("LeaveTypeUpdatedBy")
- created_leave_requests LeaveRequest[] @relation("LeaveRequestCreatedBy")
- updated_leave_requests LeaveRequest[] @relation("LeaveRequestUpdatedBy")
- approved_leave_requests LeaveRequest[] @relation("LeaveRequestApprovedBy")

Add relation to Employee model:
- leave_requests LeaveRequest[]

Run `pnpm db:push` to apply schema changes.
  </action>
  <verify>
Run `pnpm db:push` succeeds without errors.
Run `pnpm prisma generate` succeeds.
Check prisma/schema.prisma contains model LeaveType and LeaveRequest.
  </verify>
  <done>LeaveType and LeaveRequest models exist in schema, database migrated successfully</done>
</task>

<task type="auto">
  <name>Task 2: Create leave validation schemas and leave type CRUD API</name>
  <files>
    src/lib/validations/leave.ts
    src/app/api/leave-types/route.ts
    src/app/api/leave-types/[id]/route.ts
  </files>
  <action>
Create validation schemas in src/lib/validations/leave.ts:

```typescript
import { z } from 'zod';

export const leaveTypeCreateSchema = z.object({
  name: z.string().min(2).max(50),
  code: z.string().min(1).max(10).toUpperCase(),
  description: z.string().max(500).optional(),
  annualQuota: z.number().min(0).max(365).default(0),
  maxCarryForward: z.number().min(0).max(365).default(0),
  isPaid: z.boolean().default(true),
  requiresApproval: z.boolean().default(true),
  minDaysNotice: z.number().int().min(0).default(0),
});

export const leaveTypeUpdateSchema = leaveTypeCreateSchema.partial();

export const leaveRequestCreateSchema = z.object({
  leaveTypeId: z.string().cuid(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  isHalfDay: z.boolean().default(false),
  halfDayPeriod: z.enum(['FIRST_HALF', 'SECOND_HALF']).optional(),
  reason: z.string().min(3).max(1000),
}).refine((data) => {
  // If half day, start and end date must be same
  if (data.isHalfDay) {
    const start = new Date(data.startDate).setHours(0, 0, 0, 0);
    const end = new Date(data.endDate).setHours(0, 0, 0, 0);
    return start === end;
  }
  return true;
}, { message: 'Half-day leave must be for a single day' }).refine((data) => {
  // If half day, period must be specified
  if (data.isHalfDay && !data.halfDayPeriod) {
    return false;
  }
  return true;
}, { message: 'Half-day period must be specified for half-day leave' }).refine((data) => {
  // End date must be >= start date
  return new Date(data.endDate) >= new Date(data.startDate);
}, { message: 'End date must be on or after start date' });

export const leaveRequestActionSchema = z.object({
  action: z.enum(['approve', 'reject', 'cancel']),
  reason: z.string().max(500).optional(),
});

// Helper to calculate leave days between two dates
export function calculateLeaveDays(startDate: Date, endDate: Date, isHalfDay: boolean): number {
  if (isHalfDay) return 0.5;

  const start = new Date(startDate);
  const end = new Date(endDate);
  start.setHours(0, 0, 0, 0);
  end.setHours(0, 0, 0, 0);

  let days = 0;
  const current = new Date(start);

  while (current <= end) {
    const dayOfWeek = current.getDay();
    // Skip weekends (Saturday=6, Sunday=0)
    if (dayOfWeek !== 0 && dayOfWeek !== 6) {
      days++;
    }
    current.setDate(current.getDate() + 1);
  }

  return days;
}
```

Create leave type list/create API at src/app/api/leave-types/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { leaveTypeCreateSchema } from '@/lib/validations/leave';
import { ZodError } from 'zod';

export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const activeOnly = searchParams.get('activeOnly') === 'true';

    const where = activeOnly ? { is_active: true } : {};

    const leaveTypes = await prisma.leaveType.findMany({
      where,
      orderBy: { name: 'asc' },
    });

    return NextResponse.json(leaveTypes);
  } catch (error) {
    console.error('Leave types list error:', error);
    return NextResponse.json({ error: 'Failed to fetch leave types' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const validated = leaveTypeCreateSchema.parse(body);

    const leaveType = await prisma.leaveType.create({
      data: {
        name: validated.name,
        code: validated.code,
        description: validated.description,
        annual_quota: validated.annualQuota,
        max_carry_forward: validated.maxCarryForward,
        is_paid: validated.isPaid,
        requires_approval: validated.requiresApproval,
        min_days_notice: validated.minDaysNotice,
        created_by: session.user.id,
        updated_by: session.user.id,
      },
    });

    return NextResponse.json(leaveType, { status: 201 });
  } catch (error) {
    console.error('Leave type create error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    if (error instanceof Error && error.message.includes('Unique constraint')) {
      return NextResponse.json({ error: 'Leave type name or code already exists' }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to create leave type' }, { status: 500 });
  }
}
```

Create leave type detail API at src/app/api/leave-types/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { leaveTypeUpdateSchema } from '@/lib/validations/leave';
import { ZodError } from 'zod';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const leaveType = await prisma.leaveType.findUnique({ where: { id } });

    if (!leaveType) {
      return NextResponse.json({ error: 'Leave type not found' }, { status: 404 });
    }

    return NextResponse.json(leaveType);
  } catch (error) {
    console.error('Leave type get error:', error);
    return NextResponse.json({ error: 'Failed to fetch leave type' }, { status: 500 });
  }
}

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const body = await request.json();
    const validated = leaveTypeUpdateSchema.parse(body);

    const existing = await prisma.leaveType.findUnique({ where: { id } });

    if (!existing) {
      return NextResponse.json({ error: 'Leave type not found' }, { status: 404 });
    }

    const leaveType = await prisma.leaveType.update({
      where: { id },
      data: {
        name: validated.name,
        code: validated.code,
        description: validated.description,
        annual_quota: validated.annualQuota,
        max_carry_forward: validated.maxCarryForward,
        is_paid: validated.isPaid,
        requires_approval: validated.requiresApproval,
        min_days_notice: validated.minDaysNotice,
        updated_by: session.user.id,
      },
    });

    return NextResponse.json(leaveType);
  } catch (error) {
    console.error('Leave type update error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to update leave type' }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    // Check if leave type has requests
    const requestCount = await prisma.leaveRequest.count({ where: { leave_type_id: id } });

    if (requestCount > 0) {
      // Soft delete by deactivating
      await prisma.leaveType.update({
        where: { id },
        data: { is_active: false, updated_by: session.user.id },
      });
      return NextResponse.json({ message: 'Leave type deactivated (has existing requests)' });
    }

    await prisma.leaveType.delete({ where: { id } });
    return NextResponse.json({ message: 'Leave type deleted' });
  } catch (error) {
    console.error('Leave type delete error:', error);
    return NextResponse.json({ error: 'Failed to delete leave type' }, { status: 500 });
  }
}
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation passes.
Test manually:
- POST /api/leave-types creates leave type
- GET /api/leave-types returns list
- DELETE deactivates if has requests, deletes if no requests
  </verify>
  <done>Leave type CRUD API works with validation and soft-delete protection</done>
</task>

<task type="auto">
  <name>Task 3: Create leave request API with balance validation</name>
  <files>
    src/app/api/leave-requests/route.ts
    src/app/api/leave-requests/[id]/route.ts
  </files>
  <action>
Create leave request list/create API at src/app/api/leave-requests/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { leaveRequestCreateSchema, calculateLeaveDays } from '@/lib/validations/leave';
import { ZodError } from 'zod';

export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const employeeId = searchParams.get('employeeId');
    const status = searchParams.get('status');
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');

    const where: any = {};

    // Role-based access control
    if (session.user.role === 'EMPLOYEE') {
      where.employee_id = session.user.employeeId;
    } else if (session.user.role === 'PAYROLL_MANAGER') {
      // Managers see their direct reports' requests (for approval)
      if (session.user.employeeId) {
        const managedEmployees = await prisma.employee.findMany({
          where: { reporting_manager_id: session.user.employeeId },
          select: { id: true }
        });
        const managedIds = managedEmployees.map(e => e.id);
        managedIds.push(session.user.employeeId);
        where.employee_id = { in: managedIds };
      }
    } else if (employeeId) {
      where.employee_id = employeeId;
    }

    if (status) {
      where.status = status;
    }

    const [requests, total] = await Promise.all([
      prisma.leaveRequest.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { created_at: 'desc' },
        include: {
          employee: {
            select: { id: true, first_name: true, last_name: true, employee_code: true }
          },
          leave_type: {
            select: { id: true, name: true, code: true, is_paid: true }
          },
          approver: {
            select: { id: true, name: true }
          }
        }
      }),
      prisma.leaveRequest.count({ where })
    ]);

    return NextResponse.json({
      requests,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      }
    });
  } catch (error) {
    console.error('Leave requests list error:', error);
    return NextResponse.json({ error: 'Failed to fetch leave requests' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !session.user.employeeId) {
    return NextResponse.json({ error: 'Unauthorized or no employee profile' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const validated = leaveRequestCreateSchema.parse(body);

    const startDate = new Date(validated.startDate);
    const endDate = new Date(validated.endDate);

    // Calculate leave days (excluding weekends)
    const daysCount = calculateLeaveDays(startDate, endDate, validated.isHalfDay);

    // Get leave type
    const leaveType = await prisma.leaveType.findUnique({
      where: { id: validated.leaveTypeId }
    });

    if (!leaveType || !leaveType.is_active) {
      return NextResponse.json({ error: 'Invalid or inactive leave type' }, { status: 400 });
    }

    // Check minimum days notice
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffDays = Math.ceil((startDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

    if (diffDays < leaveType.min_days_notice) {
      return NextResponse.json({
        error: `This leave type requires ${leaveType.min_days_notice} days advance notice`
      }, { status: 400 });
    }

    // Check for overlapping leave requests
    const overlapping = await prisma.leaveRequest.findFirst({
      where: {
        employee_id: session.user.employeeId,
        status: { in: ['PENDING', 'APPROVED'] },
        OR: [
          { start_date: { lte: endDate }, end_date: { gte: startDate } }
        ]
      }
    });

    if (overlapping) {
      return NextResponse.json({ error: 'Overlapping leave request exists' }, { status: 400 });
    }

    // Check leave balance
    const currentYear = startDate.getFullYear();
    const leaveBalance = await prisma.leaveBalance.findFirst({
      where: {
        employee_id: session.user.employeeId,
        leave_type: leaveType.code,
        year: currentYear,
      }
    });

    // Calculate pending leave days for this type
    const pendingLeave = await prisma.leaveRequest.aggregate({
      where: {
        employee_id: session.user.employeeId,
        leave_type_id: validated.leaveTypeId,
        status: { in: ['PENDING', 'APPROVED'] },
        start_date: { gte: new Date(currentYear, 0, 1) },
        end_date: { lte: new Date(currentYear, 11, 31) },
      },
      _sum: { days_count: true }
    });

    const usedDays = pendingLeave._sum.days_count || 0;
    const availableBalance = (leaveBalance?.balance || leaveType.annual_quota) - usedDays;

    if (daysCount > availableBalance) {
      return NextResponse.json({
        error: `Insufficient leave balance. Available: ${availableBalance}, Requested: ${daysCount}`
      }, { status: 400 });
    }

    // Create leave request
    const leaveRequest = await prisma.leaveRequest.create({
      data: {
        employee_id: session.user.employeeId,
        leave_type_id: validated.leaveTypeId,
        start_date: startDate,
        end_date: endDate,
        days_count: daysCount,
        is_half_day: validated.isHalfDay,
        half_day_period: validated.halfDayPeriod,
        reason: validated.reason,
        status: leaveType.requires_approval ? 'PENDING' : 'APPROVED',
        approved_at: leaveType.requires_approval ? null : new Date(),
        created_by: session.user.id,
        updated_by: session.user.id,
      },
      include: {
        leave_type: { select: { name: true, code: true } }
      }
    });

    return NextResponse.json(leaveRequest, { status: 201 });
  } catch (error) {
    console.error('Leave request create error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to create leave request' }, { status: 500 });
  }
}
```

Create leave request detail API at src/app/api/leave-requests/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { leaveRequestActionSchema } from '@/lib/validations/leave';
import { ZodError } from 'zod';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const leaveRequest = await prisma.leaveRequest.findUnique({
      where: { id },
      include: {
        employee: {
          select: { id: true, first_name: true, last_name: true, employee_code: true }
        },
        leave_type: true,
        approver: { select: { id: true, name: true } }
      }
    });

    if (!leaveRequest) {
      return NextResponse.json({ error: 'Leave request not found' }, { status: 404 });
    }

    // Check access
    if (session.user.role === 'EMPLOYEE' && leaveRequest.employee_id !== session.user.employeeId) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    return NextResponse.json(leaveRequest);
  } catch (error) {
    console.error('Leave request get error:', error);
    return NextResponse.json({ error: 'Failed to fetch leave request' }, { status: 500 });
  }
}

// Approve/Reject/Cancel leave request
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const body = await request.json();
    const validated = leaveRequestActionSchema.parse(body);

    const leaveRequest = await prisma.leaveRequest.findUnique({
      where: { id },
      include: { employee: { select: { reporting_manager_id: true } } }
    });

    if (!leaveRequest) {
      return NextResponse.json({ error: 'Leave request not found' }, { status: 404 });
    }

    // Permission checks based on action
    if (validated.action === 'cancel') {
      // Only the employee who created can cancel, and only if pending
      if (leaveRequest.employee_id !== session.user.employeeId) {
        return NextResponse.json({ error: 'Only the applicant can cancel' }, { status: 403 });
      }
      if (leaveRequest.status !== 'PENDING') {
        return NextResponse.json({ error: 'Can only cancel pending requests' }, { status: 400 });
      }

      const updated = await prisma.leaveRequest.update({
        where: { id },
        data: {
          status: 'CANCELLED',
          cancelled_at: new Date(),
          cancellation_reason: validated.reason,
          updated_by: session.user.id,
        }
      });

      return NextResponse.json(updated);
    }

    // Approve/Reject requires manager or admin permission
    const isManager = leaveRequest.employee.reporting_manager_id === session.user.employeeId;
    const isAdmin = ['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role);

    if (!isManager && !isAdmin) {
      return NextResponse.json({ error: 'Not authorized to approve/reject this request' }, { status: 403 });
    }

    if (leaveRequest.status !== 'PENDING') {
      return NextResponse.json({ error: 'Can only approve/reject pending requests' }, { status: 400 });
    }

    if (validated.action === 'approve') {
      const updated = await prisma.leaveRequest.update({
        where: { id },
        data: {
          status: 'APPROVED',
          approved_by: session.user.id,
          approved_at: new Date(),
          updated_by: session.user.id,
        }
      });

      // Update leave balance (deduct used days)
      const year = new Date(leaveRequest.start_date).getFullYear();
      const leaveType = await prisma.leaveType.findUnique({ where: { id: leaveRequest.leave_type_id } });

      if (leaveType) {
        await prisma.leaveBalance.upsert({
          where: {
            employee_id_leave_type_year: {
              employee_id: leaveRequest.employee_id,
              leave_type: leaveType.code,
              year,
            }
          },
          create: {
            employee_id: leaveRequest.employee_id,
            leave_type: leaveType.code,
            year,
            opening: leaveType.annual_quota,
            accrued: 0,
            used: leaveRequest.days_count,
            balance: leaveType.annual_quota - leaveRequest.days_count,
            created_by: session.user.id,
            updated_by: session.user.id,
          },
          update: {
            used: { increment: leaveRequest.days_count },
            balance: { decrement: leaveRequest.days_count },
            updated_by: session.user.id,
          }
        });
      }

      return NextResponse.json(updated);
    }

    if (validated.action === 'reject') {
      if (!validated.reason) {
        return NextResponse.json({ error: 'Rejection reason is required' }, { status: 400 });
      }

      const updated = await prisma.leaveRequest.update({
        where: { id },
        data: {
          status: 'REJECTED',
          approved_by: session.user.id,
          approved_at: new Date(),
          rejection_reason: validated.reason,
          updated_by: session.user.id,
        }
      });

      return NextResponse.json(updated);
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
  } catch (error) {
    console.error('Leave request action error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to process leave request' }, { status: 500 });
  }
}
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation passes.
Test manually:
- POST /api/leave-requests creates request with balance validation
- GET /api/leave-requests returns requests filtered by role
- PATCH /api/leave-requests/[id] with action=approve updates balance
  </verify>
  <done>Leave request API validates balance, creates requests, and handles approval workflow</done>
</task>

</tasks>

<verification>
1. Run `pnpm db:push` - schema migrates successfully
2. Run `pnpm tsc --noEmit` - no TypeScript errors
3. Run `pnpm build` - build completes
4. Manual API tests:
   - Create leave type with quota
   - Apply for leave validates against balance
   - Overlapping requests rejected
   - Approve deducts from balance
   - Cancel only works for pending
</verification>

<success_criteria>
- LeaveType and LeaveRequest models exist in database
- Admin can create/update/delete leave types
- Employee can view leave types
- Employee can apply for leave with date range
- System validates: balance, overlaps, notice period
- Manager/Admin can approve/reject requests
- Approval deducts from LeaveBalance
- Employee can cancel pending requests
</success_criteria>

<output>
After completion, create `.planning/phases/02-time-attendance/02-02-SUMMARY.md`
</output>
