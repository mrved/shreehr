---
phase: 02-time-attendance
plan: 05
type: execute
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - src/app/api/attendance/lock/route.ts
  - src/app/api/attendance/corrections/route.ts
  - src/app/api/attendance/corrections/[id]/route.ts
  - src/app/(dashboard)/attendance/lock/page.tsx
  - src/components/attendance/attendance-lock-manager.tsx
autonomous: true

must_haves:
  truths:
    - "System locks attendance 5 days before payroll processing"
    - "Admin can view and manage attendance lock status"
    - "Correction requests can be submitted for locked periods"
    - "Approved corrections update attendance records"
  artifacts:
    - path: "src/app/api/attendance/lock/route.ts"
      provides: "Attendance lock management"
      exports: ["GET", "POST"]
    - path: "src/app/api/attendance/corrections/route.ts"
      provides: "Correction request submission"
      exports: ["GET", "POST"]
    - path: "src/app/(dashboard)/attendance/lock/page.tsx"
      provides: "Attendance lock admin page"
      min_lines: 30
  key_links:
    - from: "src/app/api/attendance/lock/route.ts"
      to: "prisma.attendanceLock"
      via: "database create"
      pattern: "prisma\\.attendanceLock\\.create"
    - from: "src/app/api/attendance/corrections/[id]/route.ts"
      to: "prisma.attendance"
      via: "update on approval"
      pattern: "prisma\\.attendance\\.update"
---

<objective>
Create the attendance locking mechanism for payroll processing with correction workflow.

Purpose: Lock attendance 5 days before payroll cut-off to ensure accurate salary calculations. Provide a workflow for employees to request corrections for locked periods with admin approval.
Output: Attendance lock API, correction request API, admin lock management UI
</objective>

<execution_context>
@C:\Users\ved\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ved\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-time-attendance/02-01-SUMMARY.md
@.planning/phases/02-time-attendance/02-03-SUMMARY.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AttendanceCorrection model and create lock/correction APIs</name>
  <files>
    prisma/schema.prisma
    src/app/api/attendance/lock/route.ts
    src/app/api/attendance/corrections/route.ts
    src/app/api/attendance/corrections/[id]/route.ts
  </files>
  <action>
First, add AttendanceCorrection model to prisma/schema.prisma:

```prisma
model AttendanceCorrection {
  id              String   @id @default(cuid())
  attendance_id   String
  attendance      Attendance @relation(fields: [attendance_id], references: [id])

  // Requested changes
  new_check_in    DateTime?
  new_check_out   DateTime?
  reason          String

  status          CorrectionStatus @default(PENDING)

  // Approval tracking
  approved_by     String?
  approver        User?    @relation("CorrectionApprovedBy", fields: [approved_by], references: [id])
  approved_at     DateTime?
  rejection_reason String?

  // Audit fields
  created_at      DateTime @default(now())
  created_by      String?
  creator         User?    @relation("CorrectionCreatedBy", fields: [created_by], references: [id])
  updated_at      DateTime @updatedAt
  updated_by      String?
  updater         User?    @relation("CorrectionUpdatedBy", fields: [updated_by], references: [id])

  @@map("attendance_corrections")
}

enum CorrectionStatus {
  PENDING
  APPROVED
  REJECTED
}
```

Add relation to Attendance model:
- corrections AttendanceCorrection[]

Add relations to User model:
- created_corrections AttendanceCorrection[] @relation("CorrectionCreatedBy")
- updated_corrections AttendanceCorrection[] @relation("CorrectionUpdatedBy")
- approved_corrections AttendanceCorrection[] @relation("CorrectionApprovedBy")

Run `pnpm db:push` to apply schema changes.

Create attendance lock API at src/app/api/attendance/lock/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';

// Get lock status for a specific month/year
export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const month = parseInt(searchParams.get('month') || String(new Date().getMonth() + 1));
    const year = parseInt(searchParams.get('year') || String(new Date().getFullYear()));

    const lock = await prisma.attendanceLock.findUnique({
      where: { month_year: { month, year } },
      include: {
        locker: { select: { name: true } }
      }
    });

    // Check if we're within 5 days of month end (auto-lock zone)
    const today = new Date();
    const endOfMonth = new Date(year, month, 0); // Last day of target month
    const daysUntilLock = Math.ceil((endOfMonth.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    const shouldAutoLock = daysUntilLock <= 5 && month === today.getMonth() + 1 && year === today.getFullYear();

    return NextResponse.json({
      month,
      year,
      isLocked: !!lock,
      lock,
      daysUntilAutoLock: shouldAutoLock ? Math.max(0, daysUntilLock) : null,
      canUnlock: lock ? !!lock.unlock_approved_at : true,
    });
  } catch (error) {
    console.error('Lock status error:', error);
    return NextResponse.json({ error: 'Failed to get lock status' }, { status: 500 });
  }
}

// Lock or unlock attendance for a month
export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { month, year, action } = body;

    if (!month || !year || !action) {
      return NextResponse.json({ error: 'Month, year, and action are required' }, { status: 400 });
    }

    if (action === 'lock') {
      // First sync attendance to ensure all leave days are marked
      // (Attendance sync should be called separately before locking)

      const lock = await prisma.attendanceLock.upsert({
        where: { month_year: { month, year } },
        create: {
          month,
          year,
          locked_by: session.user.id,
        },
        update: {
          locked_at: new Date(),
          locked_by: session.user.id,
          // Clear any unlock approval
          unlock_approved_by: null,
          unlock_approved_at: null,
        }
      });

      return NextResponse.json({
        message: `Attendance locked for ${month}/${year}`,
        lock
      });
    }

    if (action === 'request-unlock') {
      const { reason } = body;
      if (!reason) {
        return NextResponse.json({ error: 'Unlock reason is required' }, { status: 400 });
      }

      const lock = await prisma.attendanceLock.update({
        where: { month_year: { month, year } },
        data: {
          unlock_requested_by: session.user.id,
          unlock_requested_at: new Date(),
          unlock_reason: reason,
        }
      });

      return NextResponse.json({
        message: 'Unlock request submitted',
        lock
      });
    }

    if (action === 'approve-unlock') {
      // Only SUPER_ADMIN or ADMIN can approve unlock
      if (!['ADMIN', 'SUPER_ADMIN'].includes(session.user.role)) {
        return NextResponse.json({ error: 'Only admin can approve unlock' }, { status: 403 });
      }

      const lock = await prisma.attendanceLock.update({
        where: { month_year: { month, year } },
        data: {
          unlock_approved_by: session.user.id,
          unlock_approved_at: new Date(),
        }
      });

      return NextResponse.json({
        message: 'Unlock approved - corrections can now be made',
        lock
      });
    }

    if (action === 'remove-lock') {
      // Only SUPER_ADMIN can completely remove a lock
      if (session.user.role !== 'SUPER_ADMIN') {
        return NextResponse.json({ error: 'Only super admin can remove locks' }, { status: 403 });
      }

      await prisma.attendanceLock.delete({
        where: { month_year: { month, year } }
      });

      return NextResponse.json({
        message: `Attendance lock removed for ${month}/${year}`
      });
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
  } catch (error) {
    console.error('Lock action error:', error);
    return NextResponse.json({ error: 'Failed to process lock action' }, { status: 500 });
  }
}
```

Create correction request API at src/app/api/attendance/corrections/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { z } from 'zod';
import { ZodError } from 'zod';

const correctionCreateSchema = z.object({
  attendanceId: z.string().cuid(),
  newCheckIn: z.string().datetime().optional(),
  newCheckOut: z.string().datetime().optional(),
  reason: z.string().min(10).max(500),
}).refine(data => data.newCheckIn || data.newCheckOut, {
  message: 'At least one of newCheckIn or newCheckOut is required'
});

// Get correction requests
export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get('status');
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');

    const where: any = {};

    // Role-based access
    if (session.user.role === 'EMPLOYEE') {
      where.creator = { id: session.user.id };
    }

    if (status) {
      where.status = status;
    }

    const [corrections, total] = await Promise.all([
      prisma.attendanceCorrection.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { created_at: 'desc' },
        include: {
          attendance: {
            include: {
              employee: { select: { first_name: true, last_name: true, employee_code: true } }
            }
          },
          creator: { select: { name: true } },
          approver: { select: { name: true } }
        }
      }),
      prisma.attendanceCorrection.count({ where })
    ]);

    return NextResponse.json({
      corrections,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      }
    });
  } catch (error) {
    console.error('Corrections list error:', error);
    return NextResponse.json({ error: 'Failed to fetch corrections' }, { status: 500 });
  }
}

// Submit correction request
export async function POST(request: NextRequest) {
  const session = await auth();
  if (!session?.user || !session.user.employeeId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const validated = correctionCreateSchema.parse(body);

    // Get attendance record
    const attendance = await prisma.attendance.findUnique({
      where: { id: validated.attendanceId }
    });

    if (!attendance) {
      return NextResponse.json({ error: 'Attendance record not found' }, { status: 404 });
    }

    // Verify employee owns this attendance
    if (attendance.employee_id !== session.user.employeeId) {
      return NextResponse.json({ error: 'Can only request corrections for your own attendance' }, { status: 403 });
    }

    // Check if period is locked
    const attendanceDate = new Date(attendance.date);
    const lock = await prisma.attendanceLock.findUnique({
      where: {
        month_year: {
          month: attendanceDate.getMonth() + 1,
          year: attendanceDate.getFullYear()
        }
      }
    });

    if (!lock) {
      return NextResponse.json({
        error: 'Period is not locked - you can edit attendance directly'
      }, { status: 400 });
    }

    if (!lock.unlock_approved_at) {
      return NextResponse.json({
        error: 'Period is locked and no unlock has been approved. Request unlock first.'
      }, { status: 400 });
    }

    // Check for existing pending correction
    const existingCorrection = await prisma.attendanceCorrection.findFirst({
      where: {
        attendance_id: validated.attendanceId,
        status: 'PENDING'
      }
    });

    if (existingCorrection) {
      return NextResponse.json({ error: 'A pending correction already exists for this record' }, { status: 400 });
    }

    const correction = await prisma.attendanceCorrection.create({
      data: {
        attendance_id: validated.attendanceId,
        new_check_in: validated.newCheckIn ? new Date(validated.newCheckIn) : null,
        new_check_out: validated.newCheckOut ? new Date(validated.newCheckOut) : null,
        reason: validated.reason,
        created_by: session.user.id,
        updated_by: session.user.id,
      },
      include: {
        attendance: {
          include: {
            employee: { select: { first_name: true, last_name: true } }
          }
        }
      }
    });

    return NextResponse.json(correction, { status: 201 });
  } catch (error) {
    console.error('Correction create error:', error);

    if (error instanceof ZodError) {
      return NextResponse.json({ error: 'Validation failed', details: error.issues }, { status: 400 });
    }

    return NextResponse.json({ error: 'Failed to create correction request' }, { status: 500 });
  }
}
```

Create correction detail/action API at src/app/api/attendance/corrections/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db';
import { calculateAttendanceStatus } from '@/lib/validations/attendance';

// Approve or reject correction
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const session = await auth();
  if (!session?.user || !['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER'].includes(session.user.role)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = await params;

  try {
    const body = await request.json();
    const { action, rejectionReason } = body;

    const correction = await prisma.attendanceCorrection.findUnique({
      where: { id },
      include: { attendance: true }
    });

    if (!correction) {
      return NextResponse.json({ error: 'Correction not found' }, { status: 404 });
    }

    if (correction.status !== 'PENDING') {
      return NextResponse.json({ error: 'Correction already processed' }, { status: 400 });
    }

    if (action === 'approve') {
      // Calculate new work minutes and status
      const checkIn = correction.new_check_in || correction.attendance.check_in;
      const checkOut = correction.new_check_out || correction.attendance.check_out;

      let workMinutes = 0;
      let status: 'PRESENT' | 'HALF_DAY' | 'ABSENT' = 'ABSENT';

      if (checkIn && checkOut) {
        workMinutes = Math.floor((new Date(checkOut).getTime() - new Date(checkIn).getTime()) / (1000 * 60));
        status = calculateAttendanceStatus(workMinutes);
      }

      // Update attendance record
      await prisma.attendance.update({
        where: { id: correction.attendance_id },
        data: {
          check_in: correction.new_check_in || undefined,
          check_out: correction.new_check_out || undefined,
          work_minutes: workMinutes,
          status,
          is_regularized: true,
          regularized_by: session.user.id,
          regularized_at: new Date(),
          remarks: `Corrected: ${correction.reason}`,
          updated_by: session.user.id,
        }
      });

      // Update correction status
      const updated = await prisma.attendanceCorrection.update({
        where: { id },
        data: {
          status: 'APPROVED',
          approved_by: session.user.id,
          approved_at: new Date(),
          updated_by: session.user.id,
        }
      });

      return NextResponse.json({
        message: 'Correction approved and attendance updated',
        correction: updated
      });
    }

    if (action === 'reject') {
      if (!rejectionReason) {
        return NextResponse.json({ error: 'Rejection reason is required' }, { status: 400 });
      }

      const updated = await prisma.attendanceCorrection.update({
        where: { id },
        data: {
          status: 'REJECTED',
          approved_by: session.user.id,
          approved_at: new Date(),
          rejection_reason: rejectionReason,
          updated_by: session.user.id,
        }
      });

      return NextResponse.json({
        message: 'Correction rejected',
        correction: updated
      });
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
  } catch (error) {
    console.error('Correction action error:', error);
    return NextResponse.json({ error: 'Failed to process correction' }, { status: 500 });
  }
}
```
  </action>
  <verify>
Run `pnpm db:push` to apply schema changes.
Run `pnpm tsc --noEmit` to verify TypeScript compilation.
Test manually:
- POST /api/attendance/lock with action=lock creates lock
- POST /api/attendance/corrections creates correction request
- PATCH /api/attendance/corrections/[id] with action=approve updates attendance
  </verify>
  <done>Attendance lock and correction APIs created with approval workflow</done>
</task>

<task type="auto">
  <name>Task 2: Create attendance lock management UI</name>
  <files>
    src/app/(dashboard)/attendance/lock/page.tsx
    src/components/attendance/attendance-lock-manager.tsx
  </files>
  <action>
Create attendance lock manager component at src/components/attendance/attendance-lock-manager.tsx:

```tsx
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { Loader2, Lock, Unlock, AlertTriangle, Check, X } from 'lucide-react';

interface LockStatus {
  month: number;
  year: number;
  isLocked: boolean;
  lock?: {
    locked_at: string;
    locker: { name: string };
    unlock_requested_at?: string;
    unlock_reason?: string;
    unlock_approved_at?: string;
  };
  daysUntilAutoLock?: number;
  canUnlock: boolean;
}

interface Correction {
  id: string;
  attendance: {
    date: string;
    employee: { first_name: string; last_name: string; employee_code: string };
  };
  new_check_in?: string;
  new_check_out?: string;
  reason: string;
  status: string;
  created_at: string;
}

export function AttendanceLockManager() {
  const [month, setMonth] = useState(new Date().getMonth() + 1);
  const [year, setYear] = useState(new Date().getFullYear());
  const [lockStatus, setLockStatus] = useState<LockStatus | null>(null);
  const [corrections, setCorrections] = useState<Correction[]>([]);
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState(false);
  const [unlockReason, setUnlockReason] = useState('');
  const { toast } = useToast();

  useEffect(() => {
    fetchData();
  }, [month, year]);

  async function fetchData() {
    setLoading(true);
    try {
      const [lockRes, corrRes] = await Promise.all([
        fetch(`/api/attendance/lock?month=${month}&year=${year}`),
        fetch(`/api/attendance/corrections?status=PENDING&limit=50`)
      ]);

      const lockData = await lockRes.json();
      const corrData = await corrRes.json();

      setLockStatus(lockData);
      setCorrections(corrData.corrections || []);
    } catch (error) {
      console.error('Failed to fetch data:', error);
    } finally {
      setLoading(false);
    }
  }

  async function handleLockAction(action: string, reason?: string) {
    setActionLoading(true);
    try {
      const res = await fetch('/api/attendance/lock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ month, year, action, reason }),
      });

      if (res.ok) {
        const data = await res.json();
        toast({ title: data.message });
        fetchData();
      } else {
        const data = await res.json();
        toast({ title: 'Action failed', description: data.error, variant: 'destructive' });
      }
    } catch (error) {
      toast({ title: 'Action failed', variant: 'destructive' });
    } finally {
      setActionLoading(false);
      setUnlockReason('');
    }
  }

  async function handleCorrection(id: string, action: 'approve' | 'reject', rejectionReason?: string) {
    try {
      const res = await fetch(`/api/attendance/corrections/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, rejectionReason }),
      });

      if (res.ok) {
        toast({ title: `Correction ${action}d` });
        fetchData();
      } else {
        const data = await res.json();
        toast({ title: 'Action failed', description: data.error, variant: 'destructive' });
      }
    } catch (error) {
      toast({ title: 'Action failed', variant: 'destructive' });
    }
  }

  function formatDate(isoString: string) {
    return new Date(isoString).toLocaleDateString('en-IN', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  }

  function formatTime(isoString?: string) {
    if (!isoString) return '-';
    return new Date(isoString).toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
  }

  const months = [
    'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
  ];

  const years = Array.from({ length: 5 }, (_, i) => new Date().getFullYear() - 2 + i);

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6 flex justify-center">
          <Loader2 className="h-6 w-6 animate-spin" />
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      {/* Period Selector and Lock Status */}
      <Card>
        <CardHeader>
          <CardTitle>Attendance Lock Status</CardTitle>
          <CardDescription>
            Lock attendance 5 days before payroll cut-off to ensure accurate calculations
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-4 mb-6">
            <Select value={String(month)} onValueChange={(v) => setMonth(parseInt(v))}>
              <SelectTrigger className="w-40">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {months.map((m, i) => (
                  <SelectItem key={i} value={String(i + 1)}>{m}</SelectItem>
                ))}
              </SelectContent>
            </Select>

            <Select value={String(year)} onValueChange={(v) => setYear(parseInt(v))}>
              <SelectTrigger className="w-28">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {years.map(y => (
                  <SelectItem key={y} value={String(y)}>{y}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex items-center justify-between p-4 border rounded-lg">
            <div className="flex items-center gap-4">
              {lockStatus?.isLocked ? (
                <Lock className="h-8 w-8 text-red-500" />
              ) : (
                <Unlock className="h-8 w-8 text-green-500" />
              )}

              <div>
                <p className="font-medium">
                  {months[month - 1]} {year}
                </p>
                <p className="text-sm text-muted-foreground">
                  {lockStatus?.isLocked
                    ? `Locked on ${formatDate(lockStatus.lock!.locked_at)} by ${lockStatus.lock!.locker.name}`
                    : 'Not locked - attendance can be modified'}
                </p>
                {lockStatus?.lock?.unlock_approved_at && (
                  <Badge variant="secondary" className="mt-1">Unlock Approved</Badge>
                )}
              </div>
            </div>

            <div className="flex gap-2">
              {!lockStatus?.isLocked && (
                <Button onClick={() => handleLockAction('lock')} disabled={actionLoading}>
                  {actionLoading && <Loader2 className="h-4 w-4 animate-spin mr-2" />}
                  <Lock className="h-4 w-4 mr-2" />
                  Lock Period
                </Button>
              )}

              {lockStatus?.isLocked && !lockStatus.lock?.unlock_requested_at && (
                <Dialog>
                  <DialogTrigger asChild>
                    <Button variant="outline">
                      <Unlock className="h-4 w-4 mr-2" />
                      Request Unlock
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>Request Unlock</DialogTitle>
                    </DialogHeader>
                    <div className="space-y-4">
                      <div className="space-y-2">
                        <Label>Reason for unlock</Label>
                        <Textarea
                          value={unlockReason}
                          onChange={(e) => setUnlockReason(e.target.value)}
                          placeholder="Explain why corrections are needed..."
                        />
                      </div>
                      <Button
                        onClick={() => handleLockAction('request-unlock', unlockReason)}
                        disabled={!unlockReason || actionLoading}
                      >
                        Submit Request
                      </Button>
                    </div>
                  </DialogContent>
                </Dialog>
              )}

              {lockStatus?.lock?.unlock_requested_at && !lockStatus.lock.unlock_approved_at && (
                <Button onClick={() => handleLockAction('approve-unlock')} disabled={actionLoading}>
                  <Check className="h-4 w-4 mr-2" />
                  Approve Unlock
                </Button>
              )}
            </div>
          </div>

          {lockStatus?.daysUntilAutoLock !== null && lockStatus.daysUntilAutoLock <= 5 && (
            <div className="flex items-center gap-2 mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg">
              <AlertTriangle className="h-5 w-5 text-yellow-500" />
              <span className="text-sm">
                {lockStatus.daysUntilAutoLock === 0
                  ? 'This period should be locked today for payroll processing'
                  : `${lockStatus.daysUntilAutoLock} days until recommended lock date`}
              </span>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Pending Corrections */}
      <Card>
        <CardHeader>
          <CardTitle>Pending Correction Requests</CardTitle>
          <CardDescription>
            Review and approve attendance corrections for locked periods
          </CardDescription>
        </CardHeader>
        <CardContent>
          {corrections.length === 0 ? (
            <p className="text-center text-muted-foreground py-8">No pending corrections</p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Employee</TableHead>
                  <TableHead>Date</TableHead>
                  <TableHead>New Check-In</TableHead>
                  <TableHead>New Check-Out</TableHead>
                  <TableHead>Reason</TableHead>
                  <TableHead></TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {corrections.map(corr => (
                  <TableRow key={corr.id}>
                    <TableCell>
                      <div>
                        <p className="font-medium">
                          {corr.attendance.employee.first_name} {corr.attendance.employee.last_name}
                        </p>
                        <p className="text-xs text-muted-foreground">
                          {corr.attendance.employee.employee_code}
                        </p>
                      </div>
                    </TableCell>
                    <TableCell>{formatDate(corr.attendance.date)}</TableCell>
                    <TableCell>{formatTime(corr.new_check_in)}</TableCell>
                    <TableCell>{formatTime(corr.new_check_out)}</TableCell>
                    <TableCell className="max-w-[200px] truncate" title={corr.reason}>
                      {corr.reason}
                    </TableCell>
                    <TableCell>
                      <div className="flex gap-1">
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleCorrection(corr.id, 'approve')}
                        >
                          <Check className="h-4 w-4 text-green-500" />
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => {
                            const reason = prompt('Rejection reason:');
                            if (reason) handleCorrection(corr.id, 'reject', reason);
                          }}
                        >
                          <X className="h-4 w-4 text-red-500" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

Create attendance lock page at src/app/(dashboard)/attendance/lock/page.tsx:

```tsx
import { auth } from '@/lib/auth';
import { redirect } from 'next/navigation';
import { AttendanceLockManager } from '@/components/attendance/attendance-lock-manager';

export default async function AttendanceLockPage() {
  const session = await auth();
  if (!session?.user) {
    redirect('/login');
  }

  // Only admins and HR can manage locks
  if (!['ADMIN', 'SUPER_ADMIN', 'HR_MANAGER', 'PAYROLL_MANAGER'].includes(session.user.role)) {
    redirect('/attendance');
  }

  return (
    <div className="p-6">
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Attendance Lock Management</h1>
        <p className="text-muted-foreground">
          Lock attendance before payroll processing and manage correction requests
        </p>
      </div>

      <AttendanceLockManager />
    </div>
  );
}
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` to verify TypeScript compilation.
Run `pnpm build` to verify pages build correctly.
  </verify>
  <done>Attendance lock management UI created with lock controls and correction approval</done>
</task>

</tasks>

<verification>
1. Run `pnpm db:push` - schema migrates successfully
2. Run `pnpm tsc --noEmit` - no TypeScript errors
3. Run `pnpm build` - build completes
4. Manual testing:
   - Lock a month's attendance
   - Request unlock with reason
   - Approve unlock
   - Submit correction (as employee)
   - Approve correction (as admin)
   - Verify attendance record updated
</verification>

<success_criteria>
- AttendanceLock model stores lock status per month/year
- Admin can lock attendance for a month
- Lock status shows on attendance pages (users can't modify locked periods)
- Unlock request workflow with reason
- Admin can approve unlock
- Employee can submit correction for unlocked-but-previously-locked periods
- Admin can approve/reject corrections
- Approved corrections update the attendance record
</success_criteria>

<output>
After completion, create `.planning/phases/02-time-attendance/02-05-SUMMARY.md`
</output>
